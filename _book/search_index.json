[
["index.html", "Introduction to Python Chapter 1 INTRO", " Introduction to Python Łukasz Muszyński 2019-08-06 Chapter 1 INTRO About Python "],
["syntax.html", "Chapter 2 Syntax 2.1 operatory logiczne 2.2 podstawowe komendy i funkcje 2.3 control flow 2.4 Indicies 2.5 shallow and deep copies 2.6 generators 2.7 dynamic code 2.8 errors and warning", " Chapter 2 Syntax 2.1 operatory logiczne a == b a != b a &lt; b a &lt;= b a &gt; b a &gt;= b 2.2 podstawowe komendy i funkcje 2.2.1 sprawdzenie typu obiektu string = &#39;abdc&#39; liczba = 100 #(1) uzycie funkcji &#39;type&#39; type(string) == str type(string) is str type(liczba) == int type(liczba) is int #(2) uzycie funkcji &#39;insinstance&#39; isinstance(string, (int, float)) # obiekt to typ &#39;int&#39; lub &#39;float&#39; isinstance(string, (int, float, str)) # obiekt to typ &#39;int&#39; lub &#39;float&#39; lub &#39;str&#39; #(3) ROZNICA MIEDZY funkcjami &#39;type&#39; I &#39;isinstance&#39;: # Isinstance caters for inheritance (an instance of a derived class is an instance of a base class, too), while checking for equality of type does not (it demands identity of types and rejects instances of subtypes, AKA subclasses). # To co napisano powyzej ma np. znaczenie przy podklasach bedacych elementami nadklas (patrz plik o programowaniu obiektowym &#39;1_08_PROGRAMING_data_structures-objective_programing&#39;). Popatrzmy na przyklad: # definiujemy klase &#39;Vehicle&#39; class Vehicle: pass # definiujemy klase &#39;Truck&#39; bedaca podklasa klasy &#39;Vehicle&#39; class Truck(Vehicle): pass isinstance(Vehicle(), Vehicle) # returns True type(Vehicle()) == Vehicle # returns True isinstance(Truck(), Vehicle) # returns True type(Truck()) == Vehicle # returns False #(4) Sprawdzenie najbardziej podstawowych typow # array import numpy as np a1 = np.array([1,2]) type(a1) is np.ndarray # DataFrame import pandas as pd df = pd.DataFrame([1]) type(df) is pd.core.frame.DataFrame # list li = [1,2] type(li) is list # Series import pandas as pd df = pd.Series([1,2,3]) type(df) is pd.core.series.Series 2.2.2 inne komendy i funkcje # usuwanie zmiennej z=[1,2,3] del z z = [1,2,3] w = [4,5,6] del z, w # mozna tez kilka zmiennych na raz usunac # lista atrybutow i metod obiektu z = [1,2,3,4] dir(z) # wielkosci obiektu w pamieci sys.getsizeof(z) # ile w bajtach zajmuje lista w pamieci sys.getsizeof(z)/1e+6 # ile w megabajtach (decimal) zajmuje lista w pamieci sys.getsizeof(z)/1048576 # ile w megabajtach (binary) zajmuje lista w pamieci # unikalne ID obiektu id(z) # typ obiektu type(z) # czy obiekty są tożsame (silny warunek tozsamosci) w = [1,2,3] z = [1,2,3] w is z # obiekty są identyczne co do zawartosći i typu, ale to są 2 różne obiekty (mają różną lokalizację pamięci) więc dostajemy FALSE # czy obiekty sa takie same do do wartosci i typu (slaby warunek tozsamosci) w = [1,2,3] z = [1,2,3] w == z # dostajemy TRUE # trik zwiazany z przypisaniem wartosci do kilku zmiennych w jednej linii z1, z2 = [1,2] # z1 bedzie rowne 1 a z2 2 x1, x2 = 1, 2 # x1 bedzie rowne 1 a x2 2 w1, w2 = [[1,2], [3,4]] # w1 bedzie rowne [1,2] a w2 [3,4] 2.3 control flow 2.3.1 if else ‘else if’ w jednej linii. Użyteczne np. w funkcjach anonimowych # (1) Wersja pierwsza składni # ogolna skladnia expr1 if condition1 else expr2 if condition2 else expr # przyklad a = &quot;ujemna&quot; if b&lt;0 else &quot;dodatnia&quot; if b&gt;0 else &quot;zero&quot; # przyklad w funkcji anonimowej (tzw. funkcja lambda) z = [-1,-2,-1,0,1,2,3] #tworze liste list(map(lambda x : &quot;ujemna&quot; if x &lt; 0 else &quot;dodatnia&quot; if x &gt; 0 else &quot;zero&quot;, z)) # wartosci liczbowe listy przekodowuje na teksowe opisy # (2) Wersja druga składni if a &gt; b: print(&quot;a is greater than b&quot;) if else w wielu liniach # ogolna skladnia if expression1: statement(s) elif expression2: statement(s) elif expression3: statement(s) else: statement(s) # przyklad 1: a = 33 b = 200 if b &gt; a: print(&quot;b is greater than a&quot;) # przyklad 2: a = 33 b = 33 if b &gt; a: print(&quot;b is greater than a&quot;) elif a == b: print(&quot;a and b are equal&quot;) # przyklad 3: a = 200 b = 33 if b &gt; a: print(&quot;b is greater than a&quot;) elif a == b: print(&quot;a and b are equal&quot;) else: print(&quot;a is greater than b&quot;) 2.3.2 petla ‘for’ 2.3.2.1 Podstawowy for # for po liscie: fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;] for x in fruits: print(x) # for po stringu: for x in &quot;banana&quot;: print(x) # po po zakresie liczbowym: for x in range(6): print(x) # uzycie &#39;break&#39; - przerwanie petli fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;] for x in fruits: print(x) if x == &quot;banana&quot;: # w momencie kiedy petla dojdzie to &#39;banana&#39; zostaje przerwana break # uzycie &#39;continue&#39; - przeskoczenie iteracji fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;] for x in fruits: if x == &quot;banana&quot;: # kiedy petla dojdzie do &#39;banana&#39; zostanie przerwana biezaca iteracja (&#39;banana&#39; nie bedzie wydrukowane przez &#39;print&#39;) i nastąpi przeskok do kolejnej iteracji. continue print(x) 2.3.2.2 For w listach lista = [1,2,3,4,5] w = [x^2 for x in lista] # podniesienie do kwadratu kazdej liczby w liscie &#39;lista&#39; 2.3.2.3 For iterujace po kilku listach rownolegle a = [&#39;a1&#39;, &#39;a2&#39;, &#39;a3&#39;] b = [&#39;b1&#39;, &#39;b2&#39;] # pierwsza skladnia for (x, y_ in zip(a, b): print(x, y) # nie wydrukuje wartosci &#39;a3&#39; z pierwszego wektora, bo nie ma ona odpowiednika na tej samej pozycji w wektorze &#39;b&#39; # druga skladnia import itertools for (x, y) in itertools.zip_longest(a, b): print(x, y) # tym razem &#39;a3&#39; z pierwszego wektora zostanie wydrukowana 2.3.3 petla ‘while’ i = 1 while i &lt; 6: # wyswietlaj zmienna &#39;i&#39; tak długo jak jest mniejsza od 6. print(i) i += 1 # zwiekszanie wartosci zmiennej &#39;i&#39; o 1 w interacji # przerwanie petli - &#39;break&#39; i = 1 while i &lt; 6: print(i) if i == 3: break # jezeli i == 3 przerwij wykonywanie petli. i += 1 # continue - przeskoczenie iteracji i = 0 while i &lt; 6: i += 1 if i == 3: continue # jezeli i==3 zostanie przerwana biezaca iteracja (&#39;3&#39; nie bedzie wydrukowane przez &#39;print&#39;) i nastąpi przeskok do kolejnej iteracji print(i) 2.4 Indicies Logika indeksow prezentuje sie nastepujaco: +---+---+---+---+---+---+ | P | y | t | h | o | n | # wektor O 6 elementach +---+---+---+---+---+---+ 0 1 2 3 4 5 6 # indeksy dodatnie -6 -5 -4 -3 -2 -1 # indeksy ujemne #Jak widac indeksowanie liczbami dodatnimi jest od zera. #Do indeksow mozna się tez odwolywac przez ujemne wartosci. # utworzenie listy do przykladow z=[0, 1, 2, 3,4 ,5, 6, 7, 8, 9, 10] # celowo lista zawiera liczby pokrywajace sie z ich indeksami zeby było łatwiej zrozumiec rezultaty przykladow z[1:5] # indeksy od 1 do 4 (UWAGA: nie od 1 do 5 !!!!!. 5 jest obcinane ). z[:2] # pierwsze dwa indeksy z[4:] # indeksy od 4 w w gore z[1:5:2] # co drugi indeks z ineksow z przedzialu od 1 do 4. z[:6:3] # co trzeci indeks z ineksow z przedzialu od 0 do 5. z[5:1:-1] # indeksy od 5 do 2 w odwrocnej kolenjosci z[5:1:-2] # co drugi indeks z zakresu indeksow od 5 do 2 w odwroconej kolejnosci z[-4:-2] # odwolanie do ujemnych indeksow: od czwartego elementu (liczac od konca) do trzeciego elementu (liczac od konca - NIE drugiego elementu do konca !!!!) z[-4:] # odwolanie do ujemnych indeksow: od czwartego elementu (liczac od konca) od konca do konca wektora z[-4::2] # odwolanie do ujemnych indeksow: od czwartego elementu (liczac od konca) do konca wektora, ale co drugi indeks 2.5 shallow and deep copies Przyklad dla list # tworze wektor xs = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] # tworze plytka kopie wektora ys = list(xs) # Make a shallow copy #plytnosc kopii oznacze ze &#39;ys&#39; sklada sie tak naprawde ze wskaznikow do elementow &#39;xs&#39;: # zmodyfikujmy jakis element w &#39;xs&#39; xs[0][1] = &#39;X&#39; # w pierwszym elementcie zamienilem drugi podelement na wartosc &#39;X&#39; # wyswietlmy teraz &#39;ys&#39; ys # haha: tutaj tez dostalismy &#39;X&#39; - jest to dowod na to ze &#39;ys&#39; nie jest niezalezna zmienna, a tyklo lista wskanikow do &#39;xs&#39; # ale jezeli do &#39;xs&#39; dolozymy calkowicie nowy element to &#39;ys&#39; nie bedzie mial dodanego automatycznie wskanika na niego: xs.append([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]) xs # tutaj mamy dodany nowy element ys # a tutaj nie mamy nowego elementu, bo nie dodano nowego wskaznika # zeby wykonac prawdziwa kopie (czyli kopie gleboka) w przypadku list stosuje nastepujaca skladnie import copy tx=[[1, 2, 3], [4, 5, 6], [7, 8, 9]] ws = copy.deepcopy(tx) tx[0][2] = &#39;ZW&#39; tx ws # w liscie &#39;ws&#39; nie mamy wartosci &#39;ZW&#39; Przyklad dla obiektow class pies: def __init__(self, wiek): self.wiek = wiek def modyf_wiek(self, wiek_nowy): self.wiek = wiek_nowy pies = pies(wiek=10) # nasz pies bedzie mial 10 lat pies_shallow = pies pies_deep = copy.deepcopy(pies) pies.wiek pies.modyf_wiek(15) # modyfikujemy w pierwszym obiekcie wiek psa na 15 lat pies.wiek # mamy 15 lat po modyfikacji pies_shallow.wiek # tutaj mamy tez 15 lat bo to tylko plytka kopia pies_deep.wiek # tutaj dalej jest 10. Zmiana w &#39;pies&#39; nie wplynela na wartosci atrybutow &#39;pies_deep&#39; 2.6 generators Każda funkcja ktora ma w sobie wyrazenie ‘yield’ jest generatorem. Na przykladzie wyjasnimy jak dziala generator # W poniższe funkcji zamiast polecenia &#39;return&#39; umiescimy &#39;yield&#39; def my_gen(): n = 1 print(&#39;This is printed first&#39;) # Generator function contains yield statements yield n n += 1 print(&#39;This is printed second&#39;) yield n n += 1 print(&#39;This is printed at last&#39;) yield n # taraz odpalimy funckje: a = my_gen() # nic sie nie dzieje # odpalimy funkcja z uzyciem funkcji &#39;next&#39; next(a) # to co sie stalo wymaga szerszego komentarza. Gdyby na miejscu fragmentu &#39;yield n&#39; bylo &#39;return(n)&#39; funkcja doszlaby by do tego momentu, zwrocila wartosc &#39;n&#39; i jej dzialanie zostalo zakonczone. Ale tutaj mamy do czynienia z generatorem. Zobaczmy co sie bedzie dzialo dalej. next(a) # otorz funkcja po wywolaniu pierwszego &#39;yeild&#39;, zostala tylko zapauzowana. Jej stan wewnetrzny (np. wartosci zmiennych wewnatrz funkcji) jest dalej przechowywane w pamieci komputera. Wywolanie funkci &#39;my_gen()&#39; poraz drugie przez funkcje &#39;next&#39; spowodowalo odpauzowanie funkcji i wykonanie kodu od pierwszego do drugiego &#39;yielda&#39;. Zatem zapamietano z poprzedniego wykonania ze n=1, po czym dodano do n wartosc 1 i wykonano polecenie &#39;yield&#39; znowu pauzujac funkcje next(a) # nie trudno zgadnac ze teraz bedzie wykonany kod od drugiego do trzeciego yielda. next(a) # poniewaz nie ma czwartego &#39;yielda&#39; odpalenie funkcji czwarty raz konczy prace generatora # UWAGA. Iteracje funkcja &#39;next&#39; po kolejnych &#39;yieldach&#39; mozna wykonac tylko raz. Jezeli chcemy powtorzyc operacje musimy utworzyc nowy obiekt z funkcja generatora. b = my_gen() next(b) next(b) next(b) # generatory mozna odpalac w petli # Using for loop for item in my_gen(): print(item) Generowanie iteratorow inna skladnia # Intialize the list my_list = [1, 3, 6, 10] # tworzenie generatora a = (x**2 for x in my_list) # Output: 1 print(next(a)) # Output: 9 print(next(a)) # Output: 36 print(next(a)) # Output: 100 print(next(a)) # Output: StopIteration next(a) 2.7 dynamic code Dynamiczne generowanie kodu. Czasem kod ktory ma byc wykonany powinien byc wygenerowany z dynamicznie wygenerowanego stringu ktory potem trzeba wykonac tak jak by byl normalnym kodem command_1 = &quot;print(100)&quot; # polecenie pythonowe schowane w stringu exec(command_1) # wykonuje polecenie command_2 = &quot;print({x})&quot;.format(x=500) # polecenie pythonowe schowane w stringu ktory jest dynamicznie generowany z uzyciem zmiennej &#39;x&#39; exec(command_2) # wykonuje polecenie x=100 y=200 command_3=&quot;del {a}, {b}&quot;.format(a=&#39;x&#39;,b=&#39;y&#39;) # chcemy dynamicznie generowac nazwy zmiennych ktore maja byc usuniete poleceniem &#39;del&#39; exec(command_3) # usunelismy zmienne &#39;x&#39; i &#39;y&#39; 2.8 errors and warning 2.8.1 try Mechanizm umozliwa obsluge bledow. Dzieku temy nawet jezeli jakis fragment kodu zwraca blod, mozemy zrobic zabezpieczenie tak aby program mogl dalej dzialac. https://www.w3schools.com/python/python_try_except.asp #(1) najprostsza skladnia try: # po &#39;try&#39; jest blok kodu ktory chcemy obsluzyc pod katem ewentualnego bledu print(x) except: # po &#39;except&#39; okreslamy co ma sie zadziac po wystapieniu bledu print(&quot;An exception occurred&quot;) # jezeli wystapi jakis wlad # uwga: powyzszy kod powoduje ze nawet jezeli kod ujety po &#39;try&#39; zwroci blad beda wykonywane kolejne liniki kodu #(2) mozemy tez robic obsluge pod konkretny blad (bledy maja swoje nazwy do ktorych mozemy sie odnosic) try: print(x) except NameError: # Tutaj mamy &#39;except&#39; do obslugi bledu o nazwie &#39;NameError&#39;. Blad taki wystepuje kiedy dana zmienne nie istnieje print(&quot;Variable x is not defined&quot;) except: # mozemy sobie zostawic dalej obsluge dla pozostalych rodzajow bledow (moze byc wiele wyrazen &#39;exception&#39; pod &#39;try&#39;) print(&quot;Something else went wrong&quot;) #(3) jezeli chcemy zeby w razie niewystapienie bledu zostal zrealizowany jakis inny kod, to uzywamy &#39;else&#39; try: print(&quot;Hello&quot;) except: print(&quot;Something went wrong&quot;) else: # jezeli blok kodu po &#39;try&#39; nie zwrocil bledu wykonaj kod po &#39;else&#39; print(&quot;Nothing went wrong&quot;) #(4) mozemy tez chciec zeby zostal wykonany jakis kod, niezaleznie od tego czy blad wystapil czy nie. Do tego sluzy wyrazenie &#39;finally&#39;. try: print(x) except: print(&quot;Something went wrong&quot;) finally: # kod wykonywany niezaleznie od tego czy blok kodu pod &#39;try&#39; zawrocil blad. print(&quot;The &#39;try except&#39; is finished&quot;) # printed always #(5) czasem mozemy chciec zeby w razie wystapienia bledu zostala wyswietlona jego tresc: try: 1/0 except Exception as e: print(e); # dostaniemy tresc bledu wygenerowana przez wyrazenie po &#39;try&#39; (bedzie to &#39;division by zero&#39;) 2.8.2 assertion O wyrazeniu ‘assertion’: Assertions are simply boolean expressions that checks if the conditions return true or not. If it is true, the program does nothing and move to the next line of code. However, if it’s false, the program stops and THROWS an ERROR. https://www.programiz.com/python-programming/assert-statement assert 1==2, &#39;mamy blad&#39; # warunek nie jest spelniony wiec &#39;assertion&#39; zwroci nam blad i komunikat o tresci &#39;mamy blad&#39; assert 1!=2, &#39;mamy blad&#39; # warunke jest spelnioiny wiec nie dzieje sie nic. "],
["functions-and-enviroments.html", "Chapter 3 FUNCTIONS AND ENVIROMENTS 3.1 podstawowa składnia 3.2 przekazywanie argumentow przez wartosc a przekazywanie przez referencje 3.3 funkcje anonimowe 3.4 programowanie funkcyjne 3.5 wektoryzacja funkcji 3.6 rekurencja 3.7 zakres istnienia zmiennych (scoping rules) 3.8 dekoratory", " Chapter 3 FUNCTIONS AND ENVIROMENTS 3.1 podstawowa składnia rozna ilosc argumentow # prosta funkcja z dwoma argumentami def funkcja_1(a, b): return(a*b) funkcja_1(10, 10) # funkcja bez argumentow def funkcja_2(): return(random.randint(1,21)*5) # liczba losowa z przedzialu od 5 do 105 import random funkcja_2() # funkcja z nieokreslono ilosci argumentow. Zakladamy ze argumenty NIE MUSZA byc ponazywane def test_var_args(f_arg, *argv): # Pierwszy argument jest normalny argumentem. Pod argument z gwiazdka bedzie mozna podstawic dowolna ilosc argumentow bez podawania ich nazwy print(&quot;first normal arg:&quot;, f_arg) # pierwszy argument normalnie zadeklarowany z definicji funkcji for arg in argv: # wydrukowanie w petli argumentow ktore byly nieokreslone przy definiowaniu funkcji (argumenty te sa przechywowane w postaci listy) print(&quot;another arg through *argv:&quot;, arg) test_var_args(&#39;yasoob&#39;, &#39;python&#39;, &#39;eggs&#39;, &#39;test&#39;) # funkcja z nieokreslono iloscia argumentow. Zakladamy ze argumenty MUSZA byc ponazywane def greet_me(**kwargs): for key, value in kwargs.items(): print(&quot;{0} = {1}&quot;.format(key, value)) # wyswietlenie w petli nazw argumentw i ich wartosci (argumenty ktore sa nieokreslone przy definiowaniu funkcji, ale musze byc ponazywane sa przechowywane w postaci slownika) greet_me(name=&quot;LUKASZ&quot;, surname = &#39;kowalski&#39;) return # uwaga : bez &#39;return&#39; funkcja niczego nie zwroci: def funkcja_1_bez_return(a, b): a*b z = funkcja_1_bez_return(10,10) print(z) # dostajemy none # funkcje bez &#39;return&#39; stosuje sie najczescie do samego wyswietlanie wyniku def funckja_print(a, b): print(a*b) funckja_print(10, 20) # uwaga: return wcale nie musi być na koncu funkcji. def funkcja_return(a, b): return(a+b) # dalszczy kod po return print(&#39;koniec funkcji&#39;) funkcja_return(10,20) # teoretycznie return moze wystapic kilka razy w funkcji, ale w praktyce chyba rzadko się to spotyka def funkcja_multi_return(a, b): if a &gt; 0: return(a+b) else: return(a*b) funkcja_multi_return(10, 20) funkcja_multi_return(-10, 20) 3.2 przekazywanie argumentow przez wartosc a przekazywanie przez referencje Przekazywanie argumentu do funkcji przez wartosc # przekazywanie argumentu przez WARTOSC do funkcji oznacze ze w funkcji jest tworzona oddzielna kopia obiektu podawanego jako argument. W Pythonie przez wartosc sa przekazywane np. wartosci liczbowe def fun_1(a): a = 300 return(a) a = 100 fun_1(a) a # wartosc zmiennej &#39;a&#39; zdefiniowana poza funkcja dalej ma wartosc 100 a nie 300. Wynika to z tego ze funkcja &#39;fun_1&#39; stworzyla sobie kopie zmiennej &#39;a&#39; i pracowala na kopii nie naruszajac zmiennej &#39;a&#39; zdefiniowanej poza funkcja. Przekazywanie argumentu do funkcji przez referencje # przekazywanie argumentu przez REFERENCJE do funkcji oznacze ze w funkcji NIE jest tworzona oddzielna kopia obiektu przekazywanego jako argument. Do funkcji jest przekazywane tylko referencja. W Pythonie przez referencje sa przekazywane np. listy def fun_2(a): a = a.append(1000) return(a) a = [1,2,3] fun_2(a) a # struktura listy &#39;a&#39; znajdujacej sie poza funkcja zostala zmieniona. Funckja fun_2 dostala tylko referencje do listy &#39;a&#39; zdefiniowanej poza funkcja i pracowala bezposrednio na niej. Jaka jest regula co do tego ktore obiekty sa przekazywane przez REFERENCJE a ktore przez WARTOSC Przez kopie przekazuje sie obiekty typu ‘immutable’, czyli takie obiekty ktorych nie da sie modyfikowac. Dlatego funkcja jest zmuszona do pracy na kopii obiektu. Przez referencje przekazuje sie obiektu typu ‘mutable’, czyli takie obiekty ktora da sie modyfikowac. Wtedy funkcja moze modyfikowac taki obiekt. Przyklady obiektow ‘immutable’: atomowe wartosci liczbowe (np. 10) atomowe wartosci tekstowe (np. ‘ala ma kota’) tuple Przyklady obiektow ‘mutable’: listy set (zbiory, np: {‘a’, ‘b’}) slowniki 3.3 funkcje anonimowe Funkcja tego typu nazywa sie anonimowymi bo mozna je tworzyc bez przypisywania do zadnej zmiennej i tym samym bez nadawania im nazwy. Dlatego sa przydatne np. aby zdefiniowac sposob wstepnego przetwarzania argumentu wewnatrz innej funkcji (patrz pierwszy przykad ponizej). a = [1,2,3,4] b = [17,12,11,10] c = [-1,-4,5,9] Celsius = [39.2, 36.5, 37.3, 37.8] Fahrenheit = map(lambda x: (float(9)/5)*x + 32, Celsius) # funkcja map wykona na kazdym elemencie wektora &#39;Celsius&#39;operacje zdefinowana przez anonimowa funkcje lambda. Funkcja lambda nie musi byc przypisana do zadnej zmiennej, dlatego jest &#39;anonimowa&#39; # funkcja lambda z pobieraniem dwoch argumentow: a = [1,2,3,4] b = [17,12,11,10] c = [-1,-4,5,9] map(lambda x,y:x+y, a,b) # lambda dostaje argument x i y. x pobieraz dane z listy &#39;a&#39; nastomiast y z listy &#39;b&#39; # funkcja lambda jezeli chcemy, mozemy tez przypisac do zmiennej i potem wywolac ta zmienna funkcja = lambda x: x**2 funkcja(10) 3.4 programowanie funkcyjne W pythonie funkcja moze byc argumentem funkcji def x(a,b): print &quot;param 1 %s param 2 %s&quot;%(a,b) def y(z,t): z(*t) y(x,(&quot;hello&quot;,&quot;manuel&quot;)) # funkcja &#39;x&#39; zostaje podana jako argument dla funkcji &#39;y&#39; Funkcja moze zwracac funkcje # tworzeni funkcje ktora produkuje nowe funkcje def fun_power(n): def fun(x): return(x**n) return(fun) # bedziemy zwracac funkcje # wyprodukujemy funkcje podnoszca liczbe do kwadratu fun_power_kwadrat = fun_power(2) fun_power_kwadrat(10) # wyprodukujemy funkcje podnoszca liczbe do szescianu fun_power_kwadrat = fun_power(2) 3.5 wektoryzacja funkcji import numpy as np def fun(x): if x &gt; 0: return(True) else: return(False) # do powyzszej funkcji nie mozemy przekazac listy wartosci. fun([1,2,3,4]) # dostaniemy blad : &quot;TypeError: &#39;&gt;&#39; not supported between instances of &#39;list&#39; and &#39;int&#39;&quot;&quot; Aby funkcja dzialala na liscie/wektorze bez uzycie petli mozemy ja zwektoryzowac. fun_vect = np.vectorize(fun) fun_vect([1,2,3,4]) # taraz funkcja dziala 3.6 rekurencja def factorial_recursive(n): # Base case: 1! = 1 if n == 1: return 1 # warunek stop - ostatnie wyliczenie gdzie funkcja nie odwoluje sie do samej siebie. # Recursive case: n! = n * (n-1)! else: return n * factorial_recursive(n-1) # rekurencyjne wywolanie funkcje przez sama siebie. factorial_recursive(5) Uzycie rekurencji do pracy z zagniezdzonymi listami # splaszczymy zagniezdzona lista def flatten(S): if S == []: return S if isinstance(S[0], list): return flatten(S[0]) + flatten(S[1:]) return S[:1] + flatten(S[1:]) s=[[1,2],[3,4]] print(&quot;Flattened list is: &quot;,flatten(s)) lista_zagniezdzona = [1, 2, [3, 4, 5], [3, [6, 7]]] # splaszczenie listy (likwidacja zagniezdzen) flatten(lista_zagniezdzona) Program Explanation 1. A variable is initialized to contain a nested list. 2. The list is passed as an argument to a recursive function to flatten the list. 3. In the function, if the list is empty, the list is returned. 4. Otherwise the function is recursively called with the sublists as the parameters until the entire list is flattened. 5. The flattened list is printed. 3.7 zakres istnienia zmiennych (scoping rules) Scope resolution via LEGB rule : In Python, the LEGB rule is used to decide the order in which the namespaces are to be searched for scope resolution. The scopes are listed below in terms of hierarchy(highest to lowest/narrowest to broadest): Local(L): Defined inside function/class Enclosed(E): Defined inside enclosing functions(Nested function concept) Global(G): Defined at the uppermost level Built-in(B): Reserved names in Python builtin modules |Buil-in | | ______________________________ | | | Global | | | | __________________ | | | | | Enclosed | | | | | | ________ | | | | | | | | | | | | | | | Local | | | | | | | |_______| | | | | | | | | | | | |__________________| | | | |_____________________________ | | | ______________________________________ local and global scope # Global Scope pi = &#39;global pi variable&#39; def inner(): pi = &#39;inner pi variable&#39; # zdefiniowanie &#39;pi&#39; lokalnie w funkcji print(pi) inner() # zwracam &#39;pi&#39; z wnetrza funkcji (local scope) print(pi) # zwracam &#39;pi&#39; z globalnej przestrzni (global scope) # UWAGA: tutaj &#39;pi&#39; nie jest zdefinionwane w funkcji. Co wtedy???? pi = &#39;global pi variable&#39; def inner_bez_pi(): print(pi) inner_bez_pi() # funkcja szuka &#39;pi&#39; poza swoją przestrzenia. Znajduje ja w globalnej przestrzeni Local, Enclosed and Global Scopes pi = &#39;global pi variable&#39; def outer(): pi = &#39;outer pi variable&#39; def inner(): # pi = &#39;inner pi variable&#39; nonlocal pi print(pi) inner() outer() # &#39;pi&#39; jest zwracane z kodu w funkcji &#39;outer&#39; znajdujacego sie na zewnatrz funkcji &#39;inner&#39; (enclosed scope) print(pi) # zwracam &#39;pi&#39; z globalnej przestrzni (global scope) Local,Enclosed,Global and Built-in Scopes # Built-in Scope from math import pi # pi = &#39;global pi variable&#39; def outer(): # pi = &#39;outer pi variable&#39; def inner(): # pi = &#39;inner pi variable&#39; print(pi) inner() outer() # nie jest zdefuniowane wewnatrz funkcji &#39;inner&#39; ani &#39;outer&#39;. Funkcja szuka w kolejnych zewnetrznych zakresach wartosci &#39;pi&#39; i znajduje ja w globalnej przestrzeni, gdzie jest zaimportowana z modulu &#39;math&#39; Uzycie operatora global foo = &#39;B&#39; def a(): global foo # funkcja bedzie pracowala na globalnie dostepnej zmiennej foo = &#39;A&#39; a() print(foo) # foo przyjmie wartosc &#39;A&#39; mimo ze napisanie bylo w wykonanie w funkcji. 3.8 dekoratory https://www.datacamp.com/community/tutorials/decorators-python # definiuje dekorator def uppercase_decorator(function): # dekorator jako argument przyjmuje funkcje ktora bedzie &quot;dekorowal&quot; def wrapper(): # nasze dekorator bedzie do przekazanej funkcji dokladam mechanizm zamiany zwracanych litere na wielkie (capital letters) func = function() make_uppercase = func.upper() return make_uppercase return wrapper # definiuje funkcje def say_hi(): return &#39;hello there&#39; say_hi() # funkcja zwraca napis pisany malymi literami # &quot;dekoruje&quot; funkcje dekoratorem @uppercase_decorator def say_hi(): return &#39;hello there&#39; say_hi() # teraz funkcja po &quot;udekorowaniu&quot; zwraca napis WIELKIMI LITERAMI. "],
["data-types.html", "Chapter 4 DATA TYPES 4.1 liczby 4.2 text 4.3 wyrazenie regularne 4.4 daty", " Chapter 4 DATA TYPES 4.1 liczby 4.1.1 tworzenie #(1) z definicji z1=1 type(z) # typ &#39;integer z2=1. type(z) # typ &#39;float&#39; #(2) z konwersji liczb (zmiana typu) z1 = 10 # mamy integer float(z1) # teraz przekonwertowalismy na float z2=10.94234 int(z2) # teraz przekonwertowalismy na integet (cala koncowka jest obcienta wiec dostalismy 10) #(3) z konwersji tekstu t1 = &#39;15&#39; int(t) t2=&#39;15.4&#39; float(t2) #(4) generowanie losowe import random random.randint(1,100) # losowa liczba calkowita z przedzialu 1-100 random.randrange(start=1, stop=100, step=1) # losowa liczba calkowita z ciagu o paremetrach analogicznych do tych w funkcji &#39;range&#39; opisanej z nastepnym podrozdziale random.uniform(a=1, b=10)*100+5 # losowa liczba z przedzialu 105-1005 4.1.2 Ciagi #wygeneruj ciag liczb calkowitych list(range(6)) # od zera do 5 (NIE do 6 !!!) list(range(2,6)) # od 2 do 5 list(range(2,10,2)) # od 2 do 5 do druga liczba # wygeneruj ciag ulamkow import pylab pylab.frange(0.5, 5.25, 0.75) # od 0.5 do 5 co 0.5 pylab.frange(0.5, 5, npts=100) # od 0.5 do 5 tak zeby uzyskac 100 liczb 4.1.3 rozne funkcje # zaokraglanie z1 = 5.4 round(z1) # 5 z2 = 5.9 round(z2) # 6 z3 = 5.323422 round(z3, ndigits=3 ) # 5.323 import math math.ceil(10.1) # zaokraglenie do gory math.floor(10.1) # zaokrlaglenie w dol # logarytm math.log(10, 3) # logarytm z 10 o podstawie 3 math.log(10) # logarytm z 10 o podstawie naturalnej math.log10(10) # logarytm z 10 o podstawie 10 # pociencie ciagu na kategorie import pandas as pd import numpy as np pd.cut(np.random.randint(0, 100, 20), range(0, 105, 10), right=False) 4.2 text UWAGA: o pracy z tekstem w kontekscie DataFrames jest materiał w pliku 1_05_PROGRAMING_data_structures-Pandas\" https://www.learnpython.org/en/Basic_String_Operations regex: https://www.w3schools.com/python/python_regex.asp https://docs.python.org/3/howto/regex.html 4.2.1 tworzenie statyczne Tworzenie bezposrednie i przez konwersje # bezposrednio z = &#39;ale ma kota&#39; # z liczb str(10) # pojedyncza wartosci [str(x) for x in [1,2]] # lista wartosci # z dat import datetime str(datetime.datetime(2010,10,10)) # data i czas str(datetime.date(2010,10,10)) # data # sklejanie s1 = &#39;ala&#39; s2 = &#39; ma kota&#39; s1 + s2 # sklejanie listy stringow funkcja &#39;join&#39; lista_stringow = [&quot;John&quot;, &quot;Peter&quot;, &quot;Vicky&quot;] x = &quot;_&quot;.join(lista_stringow) print(x) 4.2.2 Tworzenie dynamiczne - nowa skladnia z funkcja ‘format’ Ponizej sa wybrane przyklady pochodzace ze strony: https://www.programiz.com/python-programming/methods/string/format Jezeli chcesz bardziej zglebic temat to zajzyj tam. Odwolywanie do pozycyjnych argumentow #(1) puste nawiasy {} w stringu. print(&quot;{} loves {} &quot;.format(&#39;Mary&#39;, &#39;Tom&#39;)) # argumenty do nawiasow &#39;{}&#39; sa podstawione w kolejnosci w jakiej sa podane w funkcji &#39;format&#39; # w nawiasach wasatych sa indeksy odwolujace sie do pozycji argumentow w funkcji &#39;format&#39; print(&quot;{1} loves {0} .&quot;.format(&#39;Mary&#39;, &#39;Tom&#39;)) # Tuta mozemy sterowac w jakiej kolejnosci argumenty sa podstawiane do nawiasow. # w nawiasach wasatych sa nazwy odwolujace sie do nazw argumentow w funckji &#39;format&#39; print(&quot;{osoba_2} loves {osoba_1} &quot;.format(osoba_1=&#39;Mary&#39;, osoba_2=&#39;Tom&#39;)) # mozemy mieszac odwolywanie sie do indeksow i nazw argumentow znajdujacych sie w funkcji &#39;format&#39; print(&quot;{0} loves {osoba}.&quot;.format(&#39;Mary&#39;, osoba=&#39;Tom&#39;)) Formatowanie typu liczbowego # podstawienie liczb calkowitych (integer) print(&quot;The number is:{:d}&quot;.format(123)) # podstawianie liczb zmiennoprzecinkowych (float) print(&quot;The float number is:{:f}&quot;.format(123.4567898)) # podstawienie cyfr w innych formatach liczbowych (octal, binary and hexadecimal) print(&quot;bin: {0:b}, oct: {0:o}, hex: {0:x}&quot;.format(12)) # pelna lista dostepny modyfikatorow zwiaznych z typami liczbowymi: d - Decimal integer c - Corresponding Unicode character b - Binary format o - Octal format x - Hexadecimal format (lower case) X - Hexadecimal format (upper case) n - Same as &#39;d&#39;. Except it uses current locale setting for number separator e - Exponential notation. (lowercase e) E - Exponential notation (uppercase E) f - Displays fixed point number (Default: 6) F - Same as &#39;f&#39;. Except displays &#39;inf&#39; as &#39;INF&#39; and &#39;nan&#39; as &#39;NAN&#39; g - General format. Rounds number to p significant digits. (Default precision: 6) G - Same as &#39;g&#39;. Except switches to &#39;E&#39; if the number is large. % - Percentage. Multiples by 100 and puts % at the end. Formatowanie typu liczbowego z paddingiem (np. dodawanie zer na początku liczby) # integer numbers with minimum width print(&quot;{:5d}&quot;.format(12)) # width doesn&#39;t work for numbers longer than padding print(&quot;{:2d}&quot;.format(1234)) # padding for float numbers print(&quot;{:8.3f}&quot;.format(12.2346)) # integer numbers with minimum width filled with zeros print(&quot;{:05d}&quot;.format(12)) # padding for float numbers filled with zeros print(&quot;{:08.3f}&quot;.format(12.2346)) Formatowanie typu liczbowego ze znakiem (liczby dodatnie i ujemne) # show the + sign print(&quot;{:+f} {:+f}&quot;.format(12.23, -12.23)) # show the - sign only print(&quot;{:-f} {:-f}&quot;.format(12.23, -12.23)) # show space for + sign print(&quot;{: f} {: f}&quot;.format(12.23, -12.23)) Zaawansowane formatownanie typu tekstowego # string padding with left alignment print(&quot;{:5}&quot;.format(&quot;cat&quot;)) # string padding with right alignment print(&quot;{:&gt;5}&quot;.format(&quot;cat&quot;)) # string padding with center alignment print(&quot;{:^5}&quot;.format(&quot;cat&quot;)) # string padding with center alignment # and &#39;*&#39; padding character print(&quot;{:*^5}&quot;.format(&quot;cat&quot;)) 4.2.3 Tworzenie dynamiczne - stara skladnia Wczesniej zanim byla funkcja ‘format’ uzywano innej skladni. Ponizszy przyklad jest zywcem przeklejony ze strony. Nie obrabialem go bo ponizsze kody sa tylko dla uswiatomienia ze taka skladnia jest dopuszczalna. # Python program to demonstrate the use of formatting using % # Initialize variable as a string variable = &#39;15&#39; string = &quot;Variable as string = %s&quot; %(variable) print(string) # Printing as raw data print(&quot;Variable as raw data = %r&quot; %(variable)) # Convert the variable to integer # And perform check other formatting options variable = int(variable) # Without this the below statement # will give error. string = &quot;Variable as integer = %d&quot; %(variable) print(string) print(&quot;Variable as float = %f&quot; %(variable)) # lista znacznikow: # %d – integer # %f – float # %s – string # %x – hexadecimal # %o – octal 4.2.4 multiline string name = &quot;Eric&quot; profession = &quot;comedian&quot; affiliation = &quot;Monty Python&quot; # ponizej string zapiszemy w kilku oddzielych linijkach message = ( f&quot;Hi {name}. &quot; f&quot;You are a {profession}. &quot; f&quot;You were in {affiliation}.&quot; ) message # wydrukowaniu widzimy, ze mimo iz string byl w kilku linijkach jest traktowany jako calosc 4.2.5 odwolywanie sie do podstringow # po indeksach astring = &quot;Hello world ll!&quot; print(astring[3:7:2]) print(astring[3:7]) print(astring[3:7:1]) # z uzyciem wyrazen regularnych (o wyrazeniach regularnych jest oddzielny podrozdzial) import re ma = &#39;abclllldefllllgh&#39; ma1 = re.search(&#39;(l){2,}&#39;, ma) # szukam pozycji pierwszego co najmniej podwojnego wystapienia litery &#39;l&#39; ma1.group(0) # zwracam szukany podstraing # powyzsze rozwiazania ma ta wade ze szuka tylko PIERWSZEGO wystapienia. Problem rozwiazemy ponizej: ma3 = re.finditer(&#39;(l){2,}&#39;, ma) ma4=list(ma3) ma4[0].group(0) # pierwsze wystapienie ma4[1].group(0) # drugie wystapienie len(ma4) # ile bylo wyszukan 4.2.6 szukanie pozycji podstringow import re ma = &#39;abc llll def llll gh llll&#39; ma = re.search(&#39;(l){1,}&#39;, astring, re.I) # szukam pozycji pierwszego co najmniej podwojnego wystapienia litery &#39;l&#39; ma.start() # indeks poczatkowy ma.end() # indeks koncowy # powyzsze rozwiazania ma ta wade ze szuka tylko PIERWSZEGO wystapienia. # teraz wyszukamy wszystkich wystapien ma3 = re.finditer(&#39;(l){2,}&#39;, ma) ma4=list(ma3) ma4[0].start() # pozycja poczatku pierwszego wystapienia ma4[0].end() # pozycja konca pierwszego wystapienia ma4[1].start() # pozycja poczatku drugiego wystapienia ma4[1].end() # pozycja konca drugiego wystapienia 4.2.7 modyfikacja astring = &quot;Hello world ll!&quot; sub = re.sub(&#39;^H&#39;,&#39;aaa&#39;, astring) # zastap litere &#39;H&#39; ktora jest na poczatku (poczatkowa pozycja wymuszona przez &#39;^&#39;) literami &#39;aaa&#39; 4.2.8 rozne podstawowe operacje i funkcje zwiazane ze stringami astring = &quot;Hello world ll!&quot; astring print(astring.index(&quot;o&quot;)) # indeks pierwszego wystepienia listey &#39;o&#39; print(astring.count(&quot;l&quot;)) # ile razy wystepuje litera &#39;l&#39; print(astring.upper()) # zamiana na wielkie liter print(astring.lower()) # zamiana na male litery print(astring.startswith(&quot;Hello&quot;)) # czy string zaczna sie od ciagu &quot;Hello&#39; print(astring.endswith(&quot;ble&quot;)) # czy string konczy sie na ciagu &#39;ble&#39; print(astring.split(&quot; &quot;)) # rozbicie string na lista po elementach ktora sa spacja print(&#39;abc&#39;*10) # wydrukuj string &#39;abc&#39; 10 razy # ciag liter [chr(x) for x in range(97, 123)] # caly alfabet malymi literami [chr(x).upper() for x in range(97, 123)] # caly alfabet wielkimi literami 4.3 wyrazenie regularne Na razie tylko wybrane przyklady !!! import re m = m.group(0) # czy string zawiera a po ktorym stoi dowolny inny znak bool(re.search(&#39;a.&#39;, string=&#39;abc&#39;)) # True bool(re.search(&#39;a.&#39;, string=&#39;a&#39;)) # False bool(re.search(&#39;a.&#39;, string=&#39;abcd&#39;)) # True # czy string zaczyna sie od ciagu &#39;ab&#39; bool(re.search(&#39;^(ab)&#39;, &#39;abc&#39;)) # True bool(re.search(&#39;^(ab)&#39;, &#39;acb&#39;)) # False # czy string zaczyna sie na &#39;a&#39; i konczy sie na &#39;z&#39; bool(re.search(&#39;^(a).(z)$&#39;, &#39;abz&#39;)) # True bool(re.search(&#39;^(a).(z)$&#39;, &#39;acw&#39;)) # False bool(re.search(&#39;^(a).(z)$&#39;, &#39;gcz&#39;)) # False # czy string zawiera cyfre od 0 do 5 bool(re.search(&#39;[0-5]&#39;, &#39;abc 4 efg&#39;)) # True bool(re.search(&#39;[0-5]&#39;, &#39;abc 9 efg&#39;)) # False # czy string koczny sie na ciagu &#39;ab&#39; bool(re.search(&#39;(ab)$&#39;, &#39;cab&#39;)) # True bool(re.search(&#39;(ab)$&#39;, &#39;bac&#39;)) # False # czy string zawiera ciag &#39;ab&#39; lub ciag &#39;wz&#39; bool(re.search(&#39;(ab)|(wz)&#39;, &#39;abwz&#39;)) # True bool(re.search(&#39;(ab)|(wz)&#39;, &#39;abgg&#39;)) # True # czy string zawiera &#39;ab&#39; ktore jest powtorzone co najmniej 3 raz z rzedu bool(re.search(&#39;(ab){3,}&#39;, &#39;ababab&#39;)) # True bool(re.search(&#39;(ab){3,}&#39;, &#39;abab&#39;)) # False bool(re.search(&#39;(ab){3,}&#39;, &#39;abababababababababab&#39;)) # True # czy string zawiera &#39;ab&#39; ktore jest powtorzone 3 lub 4 lub 5 razy bool(re.search(&#39;(ab){3,5}&#39;, &#39;abababab&#39;)) # True bool(re.search(&#39;(ab){3,5}&#39;, &#39;abababababababababababab&#39;)) # True bool(re.search(&#39;(ab){3,5}&#39;, &#39;ab ab ab ab&#39;)) # False # czy string zawiera &#39;def&#39; ktory jest poprzedzony przez &#39;abc&#39; ? bool(re.search(&#39;(?&lt;=abc)def&#39;, &#39;abcdef&#39;)) # True bool(re.search(&#39;(?&lt;=abc)def&#39;, &#39;defabc&#39;)) # False # czy string zawiera &#39;def&#39; po ktorym jest &#39;abc&#39; ? bool(re.search(&#39;def(?=abc)&#39;, &#39;abcdef&#39;)) # False bool(re.search(&#39;def(?=abc)&#39;, &#39;defabc&#39;)) # True # czy string zawiera &#39;def&#39; ktory NIE jest poprzedzony &#39;abc&#39; bool(re.search(&#39;(?&lt;!abc)def&#39;, &#39;abcdef&#39;)) # False bool(re.search(&#39;(?&lt;!abc)def&#39;, &#39;defabc&#39;)) # True # czy string zawiera &#39;def&#39; po ktorym NIE jest &#39;abc&#39; ? bool(re.search(&#39;def(?!abc)&#39;, &#39;abcdef&#39;)) # True bool(re.search(&#39;def(?!abc)&#39;, &#39;defabc&#39;)) # False flagi (bardzo pomocna rzecz) # wyszukuj ugnorujac wielkosc liter (flaga IGNORECASE) bool(re.search(&#39;a&#39;, string=&#39;abc&#39;), flag = re.IGNORECASE) 4.4 daty UWAGA: o pracy z datami w kontekscie DataFrames jest meteriał w pliku 1_05_PROGRAMING_data_structures-Pandas\" 4.4.1 tworzenie dat import datetime # aktualny czas x = datetime.datetime.now() print(x) # aktualna data x = datetime.date.today() print(x) # tworzenie dat z liczb data = datetime.datetime(2018, 6, 1) #data czas = datetime.datetime(2018, 6, 1, 10, 10, 10) # czas sekundowy # data z tekstu https://docs.python.org/3/library/datetime.html print(datetime.datetime.strptime(&#39;24052010&#39;, &quot;%d%m%Y&quot;).date()) # pelna lista znacznikow typu %Y jest na stronie dokumentacji pakietu &#39;datatime&#39; (https://docs.python.org/3/library/datetime.html) 4.4.2 atrybuty daty import datetime czas = datetime.datetime(2018, 6, 1, 10, 10, 10) # czas sekundowy # wyciaganie informacji z daty czas.year czas.month czas.day czas.weekday() czas.isoweekday() czas.hour czas.minute czas.second import pytz czas_tz = datetime.datetime(2018, 6, 1, tzinfo=pytz.timezone(&quot;Poland&quot;)) # czas z podaniem strefy czasowej czas_tz.tzinfo # strefa czasowa (jezeli zostala okreslona) # zmiana strefy czasowej czas_tz = czas_tz.astimezone(pytz.timezone(&quot;America/Los_Angeles&quot;)) # wiecej o pracy ze strefami czasowymi # https://howchoo.com/g/ywi5m2vkodk/working-with-datetime-objects-and-timezones-in-python "],
["inkrementacja-daty.html", "Chapter 5 inkrementacja daty 5.1 roznice dat 5.2 zmiana wartosci 5.3 zaokraglanie dat 5.4 generowanie ciagu dat", " Chapter 5 inkrementacja daty import datetime czas_1 = datetime.datetime(2019, 6, 21, 10, 10, 10) # czas sekundowy # inkrementacja o dni oraz krotsze jednostki czasu. (ponizej pokazane timedelta nie obsluguje dluzszych jednostek czasowych np. miesiecy, lat i itp.) czas_1 + datetime.timedelta(20) # dodanie do daty 20 dni czas_1 + datetime.timedelta(20) # dodanie do daty 20 dni czas_1 + datetime.timedelta(hours = 20) # dodanie do daty 20 godzin czas_1 + datetime.timedelta(years = 5) # BLAD!!! - lata nie sa obslugiwane # inkrementacja o dluzszcze jednostki czasowe i inne fajne triki (funkcja relativedelta) from dateutil.relativedelta import relativedelta czas_1 + relativedelta(months=2) # dodanie do daty 2 miesiecy czas_1 + relativedelta(quarters=-2) # odjecie od daty 2 miesiecy czas_1 + relativedelta(years=1) # dodanie do daty 1 roku czas_1 + relativedelta(quarters=1) # dodanie do daty 1 roku czas_1 + relativedelta(months=1, weeks=1, hours=10) # dodanie jednego miesiaca i jednego tygodnia i 10 godzin from dateutil.relativedelta import relativedelta, MO, FR czas_1 + relativedelta(weekday=FR(+1)) # dodanie tyle czasu zeby uzyskac nastepny piatek (jezeli dzisiaj jest piatek zwracamy ta sama date!!!) czas_1 + relativedelta(days = 1, weekday=FR(1)) # dodanie tyle czasu zeby uzyskac nastepny piatek (ale w przeciwienstwie do poprzedniego przykladu, jezeli dzisiaj jest piatek to zwracamy i tak nastepny piatek) czas_1 + relativedelta(weekday=MO(-1)) # odjecie tyle czasu zeby uzyskac poprzedni poniedzialek # UWAGA - wazne rozroznienie: czas_1 + relativedelta(days = 31) # tutaj dodalismy 31 dni tak jakbysmy zrobili datetime.timedelta(31) # ALE teraz uzyjemy nie &#39;days&#39;, ale &#39;day&#39; !!! czas_1 + relativedelta(day = 31) # tutaj dodajemy rozniez dni, ale mozemy maksymalnie dodac ich tyle aby dojsc do odstatniego dnia miesiaca. 31 dni to za duzo i przyrost zostanie obciety i dostaniemy jedynie 30 czerwca. # powyzsza skladnia umozliwia robienie super trickow co pokazuja dalsze przyklady czas_1 + relativedelta(day=31, weekday=FR(-1)) # dostaniemy ostatni piatek w miesiacu datetime(1997,1,1)+relativedelta(day=4, weekday=MO(-1), weeks=+14) # find the first day of the 15th week of 1997. # UWAGA: wiecej przykladow tego typu, na : https://dateutil.readthedocs.io/en/stable/relativedelta.html 5.1 roznice dat from datetime import *; from dateutil.relativedelta import * import calendar import datetime czas_1 = datetime.datetime(2019, 6, 21, 10, 10, 10) # czas sekundowy czas_2 = datetime.datetime(2018, 5, 4, 10, 10, 10) # czas sekundowy roznica = relativedelta(czas_1, czas_2) roznica.years # roznica w latach roznica.years*12 + roznica.months # roznica w miesiacach (czas_1.date() - czas_2.date()).days # roznica w dniach # a teraz przyklad z uzyciem funkcji &#39;to_datetime&#39; z pakietu numpy import numpy as np czas_1 = datetime.datetime(2019, 6, 21, 10, 10, 10) # czas sekundowy czas_2 = datetime.datetime(2018, 5, 4, 10, 10, 10) # czas sekundowy # zeby skladnia zadziala dla lat, miesiecy itp. uzyjemy konwetsji funkcja &#39;to_date&#39; import pandas as pd (pd.to_datetime((datetime.date(2010,12,10))) - pd.to_datetime(datetime.date(2010,12,11)))/np.timedelta64(1,&#39;Y&#39;) # lata (pd.to_datetime((datetime.date(2010,12,10))) - pd.to_datetime(datetime.date(2010,12,11)))/np.timedelta64(1,&#39;m&#39;) # miesiace (pd.to_datetime((datetime.date(2010,12,10))) - pd.to_datetime(datetime.date(2010,12,11)))/np.timedelta64(1,&#39;m&#39;) # minuty 5.2 zmiana wartosci czas_1 = datetime.datetime(2019, 6, 21, 10, 10, 10) # czas sekundowy czas_1.replace(year = 2000, hour = 11) # zmiana roku i godziny 5.3 zaokraglanie dat import datetime import pandas as pd czas_1 = datetime.datetime(2019, 6, 21, 10, 10, 10) # czas sekundow czas_1 + pd.offsets.MonthBegin(0) # zaokraglam do pierwszego dnia miesiaca czas_1 + pd.offsets.MonthBegin(4) # dodaje 4 miesiace i zaokrlaglam do pierwszego dnia miesiaca czas_1 + pd.offsets.MonthEnd(4) # dodaje 4 miesiacae i zakraglam do ostatniego dnia miesiaca czas_1 + pd.offsets.MonthEnd(4) # dodaje 4 miesiacae i zakraglam do ostatniego dnia miesiaca czas_1 + pd.offsets.YearBegin(0) # zakraglam do pierwszego dnia roku # Lista dostepnych zaokraglen na stronie dokumentacji: https://pandas.pydata.org/pandas-docs/stable/reference/offset_frequency.html 5.4 generowanie ciagu dat import pandas as pd pd.date_range(start=&#39;1/1/2018&#39;, end=&#39;1/08/2018&#39;) # ciag data z zadanego przedzialu (domyslnie przyrost co jeden dzien) pd.date_range(start=&#39;2018-04-24&#39;, end=&#39;2018-05-30&#39;, periods=3) # wymus zwrocenie tylk 3 dat z przedzialu pd.date_range(start=datetime.date(2010,10,10), periods=5, freq=&#39;M&#39;) # zwroc 5 dat od &#39;2010-10-10&#39; przy czym przyrost co miesiac pd.date_range(start=&#39;1/1/2018&#39;, periods=5, freq=&#39;3M&#39;) # zwroc 5 dat od &#39;1/1/2018&#39; przy czym przyrost co 3 miesiace pd.date_range(start=&#39;1/1/2018&#39;, periods=5, tz=&#39;Asia/Tokyo&#39;) # zwroc 5 dat od &#39;1/1/2018&#39; przy czym przyrost co miesiac i dodaj strefe czasowa z Tokyo # uwga to co dostajemy wyzej do nie jest zwykla lista. Jezeli chcemy dostac lista z &#39;datetime&#39; to robimy: ciag_dat = pd.date_range(start=&#39;1/1/2018&#39;, periods=5, tz=&#39;Asia/Tokyo&#39;) ciag_dat_lista = ciag_dat.tolist() ciag_dat_lista[1] # wiecej przykladow na stronie : https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.date_range.html "],
["data-structures-basic.html", "Chapter 6 DATA STRUCTURES - basic 6.1 listy 6.2 slowniki 6.3 tuples 6.4 set (zbiory)", " Chapter 6 DATA STRUCTURES - basic 6.1 listy http://effbot.org/zone/python-list.htm 6.1.1 atrybuty listy lista = [1,2,3,4,5,6] len(lista) # ilosc elementow listy # listy mozna zagniezdzac lista_deep = [1,2,3,[4,5]] # [4,5] to lista zagniezdzona #UWAGA: len(lista_deep) # ilosc elementow to 4. Ostatni element (lista w liscie) jest traktowna przez funkcje &#39;len&#39; jako jeden caly element. 6.1.2 tworzenie listy # z definicji lista_1 = [1,2,3,4] # trick z iloczynem lista_1 = [1,2,3,4] *5 # konwersja z innych typow import numpy as np macierz = np.array([1,2,3,4]) lista_2 = list(macierz) # konwertujemy array 6.1.3 dodawanie wartosci #(1) laczenie list lista_1 = [1,2,3,4,5,6] lista_2 = [10,11] lista_3 = lista_1 + lista_2 #sklejenie dwoch list lista_1 = [1,2,3,4,5,6] lista_1.extend(lista_2) # sklejenie dwoch list lista_1 = [1,2,3,4,5,6] lista_1.append(lista_2) # doklejenie do listy_2 listy_1 jako zagniezdzonego elementu (to nie to samo co lista_1+lista_2!!!) # (2) insert wstawienie elementu po zadanym indeksie lista = [1,2,3,4] lista.insert(2, [20,30]) # dodanie listy [20,30] na trzeciej pozycji. Uwaga: ta lista bedzie zagniezdzona, czyli dziala to analogicznie do &#39;append&#39; lista # (3) wstawienie elementu po zadanym indeksie (inna skladnia) lista=[1,2,3,4] lista[0:2] + [3,4] + lista[2:] # wstawiem elementy od drugieg indektu. Tym razem nie beda one zadniezdzane jak to bylo przy funkcji &#39;insert&#39; 6.1.4 aktualizacja wartosci z=[1,2,3,4] z[1:2] = [100, 300] # modyfikacja wartosci elementu o indeksach 1 i 2 (element drugi i trzeci) z[1,2,3,4,5] z[1:2] = [100, 200 , 300] # mimo ze powalismy tylko 2 indeksy do modyfikacji a, wartosci po wstawienia są 3 wartosci nie dostaniemy błędy. Trzecia wartosc (300), zostanie &#39;wepchana miedzy 200 i 3 # modyfikacja elementow spelniajacych warunek z = [1,2,3,4,5] [0 if i &gt;=3 else i for i in z] # zamiana na zero elementow wiekszych lub rownych 3 6.1.5 usuwanie lista = [1,2,3,4,5,6] del lista[3] # usuniecie elementu o indeksie 3 lista.remove(2) # usuniecie PIERWSZEJ napotkanej wartosci # jezeli chcemy usunac wszyskie, a nie tylko pierwsza wartosc stosujemy: a = [10, 20, 30, 40, 20, 30, 40, 20, 70, 20] a = [x for x in a if x != 20] #lub a = [10, 20, 30, 40, 20, 30, 40, 20, 70, 20] a = list(filter(lambda x: x!= 20, a)) lista.clear() # usuniecie wszystkich elementow - dostajemy pusta liste us = lista.pop() # usuniecie ostatniego elementu listy i przypisanie go do zmiennej &#39;us&#39; us_1 = lista.pop(0) # usuniecie z listy elementu o indeksie 0 i przypsanie do zmiennej &#39;us_1&#39; 6.1.6 filtrowanie Pierwszy sposob to filtorwanie po indeksach (np. z[1:3:1]). Jest on omowiony w ‘Indicies’ w pliku ‘PROGRAMMING_syntax_base’ Ponizej omowimy inne sposoby. # filtrowanie funkcja filter z zastosowanie funkcji anonimowej number_list = range(-5, 5) less_than_zero = list(filter(lambda x: x &lt; 0, number_list)) # zostawiamy elementy mniejsze od zera. print(less_than_zero) #filtrowanie wektorem logicznym (zastosowanie funkcji compress) from itertools import compress list_a = [1, 2, 4, 6] logical_filter = [True, False, True, False] print(list(compress(list_a, logical_filter))) # Elementy &#39;lista_a&#39; pokrywajace sie pozycja z wartoscia TRUE w &#39;logical_filter &#39;beda zostawione. # funkcja dropwhile from itertools import dropwhile list(dropwhile(lambda x: x&lt;5, [1,4,6,4,1])) # USUNAC elementy az do napotkania pierwszego elementu nie spelniajacego warunku x&lt;5. # funkcja &#39;takewhile&#39; from itertools import takewhile # odwrotnosc funkcji &#39;dropwhile&#39; list(takewhile(lambda x: x&lt;5, [1,4,6,4,1])) # ZOSTAWIC elementy az do napotkania pierwszego elementu nie spelniajacego warunku x&lt;5. 6.1.7 wyszukiwanie indeksu # wyszuka indeks PIERWSZEGO elementu spelniajacego warunek l=[1,2,3,4,3,2,5,6,7] l.index(3) # jaki indeks ma pierwszy element o wartosci 3. Przy braku wyszukania elementu zwracany jest błąd. # wyszukaj wszystkie elementy spelniajace zadany warunek l=[1,2,3,4,3,2,5,6,7] [i for i,val in enumerate(l) if val==3] # Przy braku wyszukania zwracana jest lista o dlugosci 0. 6.1.8 sortowanie lista = [3,1,5,3,6] lista.sort() # sortuj rosnaco lista.sort(reverse=TRUE) # sortuj malejoco lista.reverse() # odwroc kolejnosc Sortowanie po kluczu # sortowanie po kluczu def takeSecond(elem): # definiuje funkcje okreslajaca jak klucz ma byc bocierany z listy return elem[1] # bede pobierał drug element (bede mial liste dwuelementowych list, gdzie drugi element to klucz) lista = [1,2,3,4] klucz = [4,1,2,3] lista_z_kluczem = list(zip(lista, klucz)) lista_z_kluczem.sort(key=takeSecond) # posortowanie po kluczu lista_z_kluczem 6.1.9 operowanie funkcjami na elementach # funckja &#39;map&#39; z uzyciem funkcji anonimowej squares = list(map(lambda x: x**2, [1,2,3,4])) # kazdy element zostanie podniesiony do kwadratu # for zagniezszony w petli squares = [x**2 for x in range(10)] # # kazdy element zostanie podniesiony do kwadratu 6.1.10 ciekawe operacje i triki na listach # funkcja reduce from functools import reduce product = reduce((lambda x, y: x * y), [1, 2, 3, 4]) # obliczenie skumulowanego iloczynu elementow (produktu) sum = reduce((lambda x, y: x + y), [1, 2, 3, 4]) # zsumowanie elementow (oczywiscie w praktyce lepiej uzywac &#39;sum&#39;) # polaczenie elementow kilku list tak, ze elementy o tej samej pozycji z kazdej listy trafiaja do jednej listy z1 = [1,2] z2 = [3,4] z3 = [5,6] list(zip(z1, z2, z3)) import itertools list(itertools.repeat([1,2],10)) # dwuplikuj liste 10 razy # splaszczenie list o jednym stopniu zagniezdzenia (jest wiele rozwiązan - to jest przykadowe) import operator l = [[1,2,3],[4,5,6], [7], [8,9]] # lista ktora ma w sobie listy (ale tylko jeden stopien zagniezdzenia) reduce(operator.concat, l) # splaszczenie # zliczenia wartosci list=[10,10,2,3,4,4] list.count(2) # zliczenie wartosci 2 6.1.11 losowe elementy import numpy as np np.random.choice([1,2,3,4], size=10, replace=True) # listy wybieram losowo 10 elementow i robie to ze zwracaniem np.random.choice([1,2,3,4], size=10, replace=True, p=[0.2,0.2,0.2,0.4]) # tutaj dodatkowo zadaje prawdopodobienstwo wylosowania kazdego elementu 6.2 slowniki 6.2.1 tworzenie # z definicji {&#39;a&#39;:1, &#39;b&#39;:[2,3]} # 1 i 2 to wartosci slownika (values) natomiast &#39;a&#39; i &#39;b&#39; to klucze (keys). Kucze i wartosci tworza pary klucz-wartosc # z dwoch list nazwy = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;] wartosci = [1,2,3,4,5] dict(zip(nazwy, wartosci)) 6.2.2 odwolywanie sie do elementow UWAGA: slowniki nie maja indeksow!!! . Nie mozna sie do elementow slownika odwolywac przez indeksy. W slownikach nie moze byc duplikatow po nazwach. d={&#39;a&#39;:1, &#39;b&#39;:2} d[1] # slownik nie ma indeksu. Odwolanie bedzie bezskuteczne d[&#39;b&#39;] # ale mozemy sie odwloac po nazwach d[[&#39;a&#39;,&#39;b&#39;]] # niestety mozna sie tylko po jednej nazwie odwolywac. Nie mozna podac listy nazw . Dostaniemy blad d[&#39;g&#39;] # jezeli odwolamy sie do NIEistniejacego elementu dostaniemy blad d.get(&#39;g&#39;) # odwolywanie sie do elementu w bezpieczny sposob, tzn jezeli nie ma danej nazwy w slowniku to miamiast bledu dostaniemy wartos None. d.setdefault(&#39;g&#39;, &#39;aaa&#39;) # w bezpieczny sposob mozna tez sie odwolac przez &#39;setdefault&#39;. Wtedy jezeli nie ma nazwy o zadanej wartosci, mozemy zadac jaka alternatywna wartosc ma zostac zwrocona (w przykladzie bedzie to &#39;aaa&#39;). d.values() # wyciagniecie wszystkich wartosci (bez kluczy) d.keys() # wyciagniecie wszystkich kluczy (bez wartosci) list(d.items()) # przeksztalcenie slownika w liste # proba utworzenia slownika z duplikatem dd = {&#39;a&#39;:1, &#39;a&#39;:1} dd # duplikat zostal usuniety # proba utworzenia duplikacu po samych nazwach dd = {&#39;a&#39;:1, &#39;a&#39;:2} dd # pozostawiony bedzie tylko element &#39;a&#39;:2 6.2.3 updating and adding a = {&#39;a&#39;:1, &#39;b&#39;:2} a[&#39;b&#39;]=20 a[&#39;c&#39;] = 40 6.2.4 removing dict = {&#39;Name&#39;: &#39;Zara&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;} del dict[&#39;Name&#39;]; # remove entry with key &#39;Name&#39; dict.clear(); # remove all entries in dict del dict ; # delete entire dictionary 6.2.5 filtering #!/bin/python3 names={1:&quot;ismail&quot;,2:&quot;ali&quot;,3:&quot;ahmet&quot;,4:&quot;elif&quot;,5:&quot;ecrin&quot;} filtered_dict = dict(filter(lambda item: item[0]%2==0 , names.items())) print(filtered_dict) for item in filtered_dict.items(): print(item) 6.2.6 nazwy dla ktorych wartosci spelniaja warunek https://thispointer.com/python-how-to-find-keys-by-value-in-dictionary/ # Get a list of keys from dictionary which has value that matches with any value in given list of values def getKeysByValues(dictOfElements, listOfValues): listOfKeys = list() listOfItems = dictOfElements.items() for item in listOfItems: if item[1] in listOfValues: listOfKeys.append(item[0]) return listOfKeys # Dictionary of strings and int dictOfWords = { &quot;hello&quot;: 56, &quot;at&quot; : 23 , &quot;test&quot; : 43, &quot;this&quot; : 97, &quot;here&quot; : 43, &quot;now&quot; : 97 } listOfKeys = getKeysByValues(dictOfWords, [43, 97] ) 6.3 tuples 6.3.1 atrybuty Tuple to struktura ktorej po utworzeniu nie mozna modyfikowac. Tak więc atrybuty są ustawione na sztywno. Dlatego nie bedzie tutaj przykladow o usuwaniu, filtorwania, zmienianiu wartosci. # utworzenie tuple z = (1,2,3,4,5) # proba modyfikacji (dostajemy blad) z[1]=100 # proba dodania elementu (dostajemy blad) z+[1,2] 6.3.2 tworzenie # z definicji z1 = (1, 2, 3, (4, 5), [6, 7]) z1 # z listy lista = [1,2,3,4] z2 = tuple(lista) z2 6.3.3 odwolywanie sie do elementow Analogocznie jak przy lista 6.4 set (zbiory) 6.4.1 tworzenie # z definicji s = {1,2,3} # z listy lista = [1,2,3,4] s = set(lista) # z tuple tuple = (1,2,3,4) s = set(tuple) 6.4.2 atrubyty Zbiory podobnie jak slowniki nie maja indeksow. W zbiorach tak jak w slownikach nie moga istniec duplikaty Z zbiorach nie mozna zagniezdzac elementow s = {1,2,3,4,5} s[1] # proba odwolania sie przez indeks - dostaniemy blad # proba utworzenia zbioru z duplikatami s = {1,1,2,2} s # duplikaty zostaly usuniete s = {1,2,3,{4,5}} # nie mozna zagniezdzac elementow. Dostaniemy blad 6.4.3 aktualizacja/dodawanie/usuwanie wartosci s = {1,2,3,4,5} s.update({10,11}) # dodanie elementow s.remove(1) # usuwanie pojedynczego elementu ze wzgledu na wartosc s.discard(2) # usuwanie pojedynczego elementu ze wzgledu na wartosc (inna skladnia) s -= {4,5} # usuwanie wielu elementow s.difference_update({1,2}) # usuwanie wielu elementow (inna skladnia) s3 = s.pop() # usuniecie ostatniego elementu i przypisanie do zmiennej &#39;s3&#39; 6.4.4 funkcje na elementach Analogicznie jak w listach: np: z = {1,2,3} set(map(lambda x: x^2, z)) # podniesienie do kwadratu kazdego elementu 6.4.5 operacje na zbiorach s1 = {1,2,3} s2 = {3,4,5} # suma zbiorow (elementy wystepujace w jednym lub drigm zbiore) s1 | s2 s1.union(s2) # alternatywna skladnia # elementy wspolne ziorow s1 &amp; s2 s1.intersection(s2) # alternatywna skladnia # roznica zbiorow s1 - s2 s1.difference(s2) # alternatywna skladnia # roznica symstryczne s1 ^ s2 s1.symmetric_difference(s2) # alternatywna skladnia # wartosc logiczna okreslajaca czy elementy nie maja elementow wspolnczy s1.isdisjoint(s2) # dostajemy Fale bo elementem wsplnym jest 3. # czy zbior jest podzbiorem dugiego zbioru s1 &lt;= s2 s1.issubset(s2) # alternatywna skladnia # czy zbior jest podzbiorem wlasciwym (proper subset) drugiego zbioru s1 &lt; s2 # czy zbior jest nadzbiorem dla drugiego zbioru s1 &gt;= s2 s1.issuperset(s2) # alternatywna skladnia # czy zior jest wlasciwym nadzbiorem dla dugiego zbioru s1 &gt; s2 "],
["data-structures-pandas.html", "Chapter 7 DATA STRUCTURES-Pandas 7.1 Series 7.2 Categorical 7.3 DATA FRAMES", " Chapter 7 DATA STRUCTURES-Pandas 7.1 Series Series zostalo stworzone glownie pod potrzeby pracy z DataFrames i glownie w tamtym kontekscie jest uzywane. Dlatego tez w tym rozdziale są tylko podstawowe informacje. Wiecej przyladow pracy z Series (w kontekście DataFrame) jest w rozdziale o DataFrame 7.1.1 tworzenie import pandas as pd # z listy s = pd.Series(data=[1,2,3,4,5], dtype=&#39;int32&#39;) # mozna wymusic typ danych # ze slownika s = pd.Series(data={&#39;a&#39;:1, &#39;b&#39;:2}) # nazwy &#39;a&#39; i &#39;b&#39; stana sie indeksami po ktorych mozemy sie odwolywac do elementow (patrz rozdzial &quot;odwolywanie sie do elementow&quot;) # z array s = pd.Series(data=np.array([1,2,3,3,4])) 7.1.2 atrybuty Jest to jednowymiarowa marzeciez (wektor). Tak jak array wszystkie elementy musza byc tego samego typu. Nie moze byc liczby i tekstu w tym samym Series W odroznieniu od normalnych macierzy, do elementow moozemy sie odwolywac zaorowno przez indeksy domyslne liczbowe, indeksy recznie zdefiniowane liczbowe, ekstra recznie zdefiniowane indeksy tekstowe (poza domyslnymi liczbowymi) Series w Pandasie mają zdefiniowane bardzo wiele przydatnych metod. DataFrame to nic innego jak zbiór kilku Series W typie series mozna zagniezszac elementy s1 = pd.Series(data=[1,2,3,4,5) s1.dtype # typ danych s1.size # ilosc elementow # mozliwosc zagniezdzania elementow s2 = pd.Series(data=[1,2,3,4,5, [6,7]]) s2[5] # wyciagniecie zaniezdzonej listy 7.1.3 Odwolywanie sie do elementow # odwolywanie sie przez domysle indeksy liczbowe, tak jak w listach s1 = pd.Series(data=[1,2,3,4,5], index=[10,20,30,40,50],dtype=&#39;int32&#39;) # indeksy mozemy samodzielnie zdefiniowac s1[3:] # odwolywanie sie przez samodzielnie okreslone indeksy LICZBOWE s2 = pd.Series(data=[1,2,3,4,5], index=[10, 20, 30, 100, 500],dtype=&#39;int32&#39;) # indeksy mozemy samodzielnie zdefiniowac rozniez jako s2[10] s2[[10,20]] # odwolywanie sie przez samodzielnie okreslone indeksy TEKSOWE s3 = pd.Series(data=[1,2,3,4,5], index=[&#39;A&#39;, &#39;B&#39;,&#39;C&#39;, &#39;D&#39;, &#39;E&#39;],dtype=&#39;int32&#39;) # indeksy mozemy samodzielnie zdefiniowac rozniez jako s3[&#39;A&#39;] s3[1] # przy recznie zdefiniowanych indeksach TEKSTOWYCH dalej mozemy odwolywac sie do domyslnych indeksow liczbowych s3 = s.reset_index() # reset indeks. Recznie zdefiniowany indkes zostanie usuniety s3[&#39;A&#39;] # dostaniemy blad 7.1.4 sortowanie s = pd.Series(data=[1,2,3,4,5], index=[&#39;E&#39;, &#39;B&#39;,&#39;C&#39;, &#39;D&#39;, &#39;A&#39;],dtype=&#39;int32&#39;) s.sort_index() # sortowanie po indeksach s.sort_values() # sortowanie po wartosciach s.sort_values(ascending=True) # sortowanie po wartosciach (malejaco) 7.1.5 dodawanie wartosci i problem z indeksami Sklejanie poziome (axis = 0) # (1) Uwaga na problem z indeksacja: po sklejeniu dwoch Series nie ma automatcznej reindeksacji s1 = pd.Series([1,2,3,4,5]) list(s1.index) # indeksy s1 s2 = pd.Series([6,7,8,9]) list(s2.index) # indeksy s2 s3 = pd.concat([s1, s2]) # sklejam s1 i s2 list(s3.index) # indeksy s3 sa sklejeniem indeksow s1 i s2 !!! # dlatego dobrze jest albo wynik automatycznie przeindeksowac: s3.index = list(range(s1.size)) # albo uzyc automatycznej reindeksacji w sklejaniu s4 = pd.concat([s1, s2], ignore_index=True) # sklejam s1 i s2 list(s4.index) # mozna tez wprowadzic indeks hierarchiczny s5 = pd.concat([s1, s2], keys=[&#39;key1&#39;, &#39;key2&#39;]) s5[&#39;key1&#39;] # wyciagam cala czesc stanowiaca elementy wektora s1 (przypisano mu glowny indeks key1) s5[&#39;key1&#39;][2] # wyciagam hiererchicznie 3 element z czesci stanowiacej elementy wektora s1 #(2) wstawienie wektora s2 do wektora s1 po drugim elemencie s1 = pd.Series([1,2,3,4,5]) s2 = pd.Series([10,20]) s3 = pd.concat([s1[:2],s2,s1[s1[2:]]], ignore_index=True) s3 Sklejanie w pionie (axis = 1) import pandas as pd # towrzymy dwa wektory o roznych indeksach s1 = pd.Series([1,2,3,4], index = [3,1,2,4]) s2 = pd.Series([1,2,3,4], index = [1,2,3,10]) # sklejami, ale tym razem axis = 1. Dostaniemy dwuwymiarowy DataFrame (s1 i s2 to kolejne wektory s1_s2 = pd.concat([s1, s2], axis=1, ignore_index=True) type(s1_s2) # DataFrame s1_s2 # wektory s1 i s2 (s1 i s2 to kolejne kolumny) w trakcie przeksztalcania w DataFrame zostaly dopasowane indeksami. Tam gdzie dla jakiegos indeksu w jednym wektorze nie ma odpowiedniku w drugim, to brak w drugiem jest wypelniamy wartoscia NaN. 7.1.6 aktualizacja wartosci import pandas as pd s = pd.Series(data=[1,2,3,4,5]) s[2:4] = pd.Series([100,200]) # podmiana elementu drugieg i trzeciego 7.1.7 rozne funkcje import pandas as pd s = pd.Series([1,2,5,-4,2,3,4,6]) s.aggregate(func=lambda x:sum(x**2)) # sumuj kwadraty elementow s.nlargest(n=4) # 4 pierwsze najwieksze elementy s.nsmallest(4) # 4 pierwsze najmniejsze elementy s.cummax() # skumulowany max s.cummin() # skumulowany min s.cumsum() # skumulowana suma s.cumprod() # skumulowany iloczyn s.shift(periods=-2) # przesunieci kazdego elementu wektora o 2 pozycje w GORE (2 pierwsze elementy zostana stracone, na dwoch ostatnich pozycjach pojawia sie braki danych) s.shift(periods=2) s_l = pd.Series([True, False, True]) s.any() # czy gdzie kolwiek True s.all() # czy gdzie wszedzie True 7.1.8 praca z brakami danych i wartowsciami nieskonczonymi Patrz przyklady w czesci o DataFrame 7.2 Categorical Danym typu Series mozna nadac typ \"categorical’ ktory jest odpowiednikiem typu ‘factor’ w programie R. 7.2.1 Tworzenie import pandas as pd #(1) funkcja &#39;Categorical&#39; c = pd.Categorical([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], ordered = None) list(s.cat.categories) # lista wystepujacych kategorii #(2) utworzenie Series typu &#39;category&#39; s = pd.Series([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;], dtype=&quot;category&quot;) # UWAGA: powyzej utworzone zmienne nie sa dokladnie tego samego typu type(c) # zdefiniowane funkcja &#39;Categorical&#39; type(s) # zdefiniowane funkcja &#39;Series&#39; # przypadku zmiennej &#39;c&#39; metody zwiazne z typem &#39;Categorical&#39; ktore posiada wywolujemy od razu po jej nazwie c.check_for_ordered() # w przypadku zmiennej &#39;s&#39; metody zwiazne z typem &#39;Categorical&#39; ktore posiada wywolujemy od razu po .cat. s.cat.check_for_ordered() #(3) Series z zagniezdzana funkcja &#39;Categorical&#39; s = pd.Series(pd.Categorical([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;], ordered=False)) # mozna wymusic uporzadkowanie #(4) utworzenie Series typu &#39;category&#39; z manualnym okresleniem zakresu kategorii # SPOSOB 1 from pandas.api.types import CategoricalDtype s = pd.Series([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;]) cat_type = CategoricalDtype(categories=[&quot;b&quot;, &quot;c&quot;, &quot;d&quot;], ordered=True) # podajemy kategorie i dodatkowo mozemy wymagac aby byl wprowadzony porzedek (order) s_cat = s.astype(cat_type) # &#39;a&#39; zostalo zamianina na NaN to nie bylo wyspecyfikowane w kategoriach # SPOSOB 2 s = pd.Series([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;], dtype=&quot;category&quot;) s.cat.set_categories([&quot;b&quot;, &quot;c&quot;, &quot;d&quot;]) #(5) przez zmiane typu w DataFrame df = pd.DataFrame({&quot;A&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;]}) df[&quot;B&quot;] = df[&quot;A&quot;].astype(&#39;category&#39;) 7.2.2 usuwanie/dodawanie/modyfikacje kategorii usuwanie #(1) usuniecie konkretnej kategorii s = pd.Series([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;], dtype=&quot;category&quot;) s1 = s.cat.remove_categories([&#39;c&#39;]) # usuniecie konkretnej kategorii #(2) usuniecie nadmiarowej kategorii s = pd.Series([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) cat_type = CategoricalDtype(categories=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]) # &#39;d&#39; jest kategoria nadmiarowa - nie ma jej realnie w wektorze &#39;s&#39; s_cat = s.astype(cat_type) s2 = s_cat.cat.remove_unused_categories() # usuniecie kategorii dla ktorych nie ma elementow w wektorze dodawanie kategorii s = pd.Series([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;], dtype=&quot;category&quot;) s.cat.add_categories([&#39;z&#39;, &#39;w&#39;]) # dodanie kategorii &#39;z&#39; i &#39;w&#39; zmiana nazw kategorii s = pd.Series([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;], dtype=&quot;category&quot;) s.cat.rename_categories({&#39;a&#39;:&#39;A&#39;, &#39;b&#39;:&#39;B&#39;}) # &#39;a&#39; zaminiam na &#39;A&#39; i &#39;b&#39; na &#39;B&#39; zmiana uporzadkowania kategorii # wymuszenie uporzedkowania nieuporzadkowanej kategorii s = pd.Series(pd.Categorical([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;], ordered = None)) s_ord = s.cat.as_ordered() # usuniecie uporzadkowania kategorii s_no_odr = s_ord.cat.as_unordered() # zmiana kolejnosci kategorii s = pd.Series([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;], dtype=&quot;category&quot;) s.cat.reorder_categories([&#39;b&#39;,&#39;a&#39;,&#39;c&#39;,&#39;d&#39;]) 7.2.3 dodawanie nowych elemntow W kontekscie samych wekrotow from pandas.api.types import union_categoricals #(1) uzycie funkcji concat s1 = pd.Series([&#39;a&#39;, &#39;b&#39;], dtype=&#39;category&#39;) s2 = pd.Series([&#39;a&#39;, &#39;b&#39;, &#39;a&#39;], dtype=&#39;category&#39;) pd.concat([s1, s2]) # Uwaga jezeli zakres kategorii wektorow sie nie zgadza to nowy sklejowy wektor bedzie typu &#39;object&#39; a nie &#39;category&#39; s1 = pd.Series([&#39;a&#39;, &#39;b&#39;], dtype=&#39;category&#39;) s2 = pd.Series([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], dtype=&#39;category&#39;) # tutaj jest kategoria &#39;c&#39; ktorej nie ma w wektorze &#39;s1&#39; pd.concat([s1, s2]) # ten problem rozwiazuje funkcja &#39;union_categoricals&#39; (patrz nastepny przyklad) #(2) uzycie funkcji union_categoricals a = pd.Categorical([&quot;b&quot;, &quot;c&quot;]) b = pd.Categorical([&quot;a&quot;, &quot;b&quot;]) # do wektora &#39;a&#39; dokleimy elementy z wektora &#39;b&#39; union_categoricals([a, b]) # mimo ze oba wektory maja rozny zakres kategorii to po zlaczeniu dalej mamy typ &#39;category&#39; W kontekscie DataFrame Jezeli sklejamy 2 ramki danych po wierszach i wystepuja tam kolumny typu ‘Categorical’ to ich kategori musza byc takie same. W przeciwnym razie dostaniemy blad. # przyklad cat = pd.Series([&quot;a&quot;, &quot;b&quot;], dtype=&quot;category&quot;) vals = [1, 2] df = pd.DataFrame({&quot;cats&quot;: cat, &quot;vals&quot;: vals}) res = pd.concat([df, df]) # sklejamy &#39;df&#39; z samym soba ( nie dostaniemy bledu bo bedzie zgodnosc kategorii) 7.3 DATA FRAMES 7.3.1 Najważniejsze atrybuty DataFrame DataFrame to nic innego jak zbiór kilku Series. Series to struktura danych dostepna w Pandasie. Wiecej o Series w rozdziale nim poswieconych. import pandas as pd df = pd.DataFrame({&#39;A&#39;:[1,2,3], &#39;B&#39;:[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]}) df.shape # ilosc wierszy i kolumn len(df) # ilosc samych wierszy df.shape[0] # ilosc samych wierszy (inna skladnia) df.shape[1] # ilosc samych kolumn df.size # ile jest elementow (komorek) df.ndim # ile wymiarowy jest obiekt df.dtypes # jakiego typu są poszczególne kolumny. UWAGA!!!: kolumny teksowe są w DataFrame domyślnie jako typ &#39;object&#39;. Dlatego kolumna &#39;B&#39; to nie jest typ &#39;text&#39; albo &#39;char&#39; ale &#39;&#39;object&#39; sys.getsizeof(df) # rozmiar w pamięci df.columns # nazwy kolumn ramki danych list(df.columns) # nazwy kolumn ramki danych jako lista 7.3.2 Tworzenie ramki danych import pandas as pd #(1) utworzenie dowolnej dwukolumnowej DataFrame z list - SPOSOB WIERSZOWY (kazda lista to wiersz). Nazwy kolumn to &#39;A&#39; i &#39;B&#39; nazwy_kolumn = [&#39;A&#39;, &#39;B&#39;] lista_1_wiersz = [1, &#39;a&#39;] lista_2_wiersz = [2, &#39;b&#39;] df_2 = pd.DataFrame(data=[lista_1_wiersz, lista_2_wiersz], columns=nazwy_kolumn) df_2 # Uwaga: kolejne elementy podaje się wierszami a nie kolumnami. Dlatego wartości 1 i &#39;a&#39; są w pierwszym wierszu a nie kolumnie. df_2.dtypes #(2) utworzenie dowolnej dwukolumnowej DataFrame z list - SPOSOB KOLUMNOWY (kazda lista to kolumna). Nazwy kolumn to &#39;A&#39; i &#39;B&#39; nazwy_kolumn = [&#39;A&#39;, &#39;B&#39;] lista_1_kolumna = [1, 2] lista_2_kolumna = [&#39;a&#39;, &#39;b&#39;] lista_list = [lista_1_kolumna, lista_2_kolumna] df_2_columns = pd.DataFrame() for i in [0,1]: df_2_columns [nazwy_kolumn[i]] = lista_list[i] df_2_columns #(3) utworzenie dowolnej dwukolumnowej DataFrame w sposob KOLUMNOWY ze słownika. Nazwy kolumn to &#39;A&#39; i &#39;B&#39;. Po nazwach podajemy listy z elementami ktore beda kolumnami slownik = {&#39;A&#39;:[1,2], &#39;B&#39;:[&#39;a&#39;,&#39;b&#39;]} df_1 = pd.DataFrame(slownik) # Powyzsza skladnia moze byc niewygodne jezeli chcemy podac nazwy kolumn w liscie # slownik mozeby wygenerowac poprzed odpowiednie sklenie listy nazw kolumn i listy samych kolumn nazwy_kolumn = [&#39;A&#39;, &#39;B&#39;] # nazwy kolumn podajemy w liscie kolumna_1 = [1,2] kolumna_2 = [3,4] slownik = dict(zip(nazwy_kolumn, [kolumna_1, kolumna_2])) df_1 = pd.DataFrame(slownik) #(4) utworzenie dowolnej dwukolumnowej DataFrame poprzez uczycie funkcji &#39;concat&#39; na sektora typu &#39;Series&#39; # towrzymy dwa wektory o roznych indeksach s1 = pd.Series([1,2,3,4], index = [3,1,2,4]) s2 = pd.Series([1,2,3,4], index = [1,2,3,10]) # sklejami, ale tym razem axis = 1. Dostaniemy dwuwymiarowy DataFrame s1_s2 = pd.concat([s1, s2], axis=1, ignore_index=True) type(s1_s2) # DataFrame #(5) utworzenie DataFrame z obiektu Array import numpy as np nazwy_kolumn = [&#39;A&#39;, &#39;B&#39;] macierz = np.array([[1,2], [3,4]]) # macierz o wymiarach 2x2 df_3 =pd.DataFrame(macierz, columns = nazwy_kolumn) df_3 # UWAGA: po wyświetleniu DataFrame widać że wartości 1 i 2 są w pierwszym wierszu a nie w pierwszej kolumnie, czyli tak tak sama sytuacja jak przy tworzeniu z listy!!!! # (6) uwtorzenie DataFrame z obiektu tupli tuple_1 = (1,&#39;a&#39;) tuple_2 = (2,&#39;b&#39;) tuple_tupli = (tuple_1, tuple_2) df_t = pd.DataFrame(list(tuple_tupli), columns = [&#39;A&#39;, &#39;B&#39;]) df_t #(7) utworzenie pustego obiektu DataFrame (przydaje się np. przy pracach w petli, kiedy w pierwszej iteracji bindujemy dane do pustej tabeli ) df_0 = pd.DataFrame() df_0 = df_0.append({&#39;A&#39;:1, &#39;B&#39;:&#39;a&#39;}, ignore_index=True) # dodanie wiersza df_0.dtypes #(8) Utworzenie DataFrame o zadanej ilosci kolumn z nazwami i brakiem wierszy df_0a = pd.DataFrame(columns = [&#39;A&#39;, &#39;B&#39;]) df_0a.dtypes # domyslnie, kolumny sa typu &#39;object&#39; 7.3.3 Uwagi o indeksach Data Frame posiada indeksacje po wierszach. Tak jak w Typie ‘Series’ mozna ja ustawiac recznie import pandas as pd df = pd.DataFrame([1,2,3,4], index = [10,20,30,40]) # sztucznie nadane indeksy wierszy Jezeli Dataframe sklejamy ‘pionowo’, z kilku obiektow typu ‘Series’, ktore maja swoje indeksy, to DataFrame w oparciu o te indeksy tworzy nowy indeks. Logika tworznia tego indeksu jest opisana w tym pliku w czesci o typie ‘Series’ w rozdziale ‘dodawanie wartosci i problem z indeksami’ (chunk kodu o sklejaniu pionowym). Dokladnie tak samo wyglada sytucja jezeli dwie DataFrames o roznych indeksach sklejamy po kolumnach (bindowanie po kolumach). Sklejanie kilku DataFrames po wierszach (bindowanie po wierszach) z roznymi indeksami: Tutaj sytuacja jest analogiczna do tej jak wystepuje w przypadku ‘sklejania poziomego’ wektorow typu Series (jest to opisane w tym pliku w czesci o typie ‘Series’ w rozdziale ‘dodawanie wartosci i problem z indeksami’ w chunku o sklejaniu poziomym) import pandas as pd # strorzmy dwa DataFrames df1 = pd.DataFrame({&#39;A&#39;:[1,2,3,4,5]}) df2 = pd.DataFrame({&#39;A&#39;:[6,7,8,9,10]}) podejzyjmy indeksy list(df1.index) # mamy : [0, 1, 2, 3, 4] list(df2.index) # mamy : [0, 1, 2, 3, 4] df3 = pd.concat([df1, df2]) df3.index # zwrocmy uwage na to ze indeks nowej tabeli df3 to sklejone indeksy df1 i df2 czyli : [0, 1, 2, 3, 4, 0, 1, 2, 3, 4] # W powyzszej sytuacji mamy 2 rozwiazania: # (1) sami mozemy zrobic reindeksacje wedlug uznanej przez siebie logiki, np.: df3.index = range(0,20,2) list(df3.index)# zrobilismy sobie index: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18] # (2) albo przy sklejeniu DataFrames mozemy uzyc argumentu &#39;ignore index&#39; df3 = pd.concat([df1, df2], ignore_index=True) list(df3.index) # teraz mamy: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 7.3.4 Wymuszanie typów kolumn w DataFrame # przykładowa strona z podstawowymi typami liczbowymi i teksowymi danych w pythonie: https://pbpython.com/pandas_dtypes.html df_t1 = pd.DataFrame( {&#39;A&#39;:[1,2,3], &#39;B&#39;:[4,5,6], &#39;C&#39;:[1,0,1], &#39;D&#39;:[10,20,30]}) # reczna zmiana typow poszczegolnych kolumn: df_t1[&#39;A&#39;] = df_t1[&#39;A&#39;].astype(&#39;int32&#39;) df_t1[&#39;B&#39;] = df_t1[&#39;B&#39;].astype(&#39;float64&#39;) df_t1[&#39;C&#39;] = df_t1[&#39;C&#39;].astype(&#39;bool&#39;) # typ logiczny df_t1[&#39;D&#39;] = df_t1[&#39;D&#39;].astype(&#39;object&#39;) # typ teksowy df_t1 df_t1.dtypes # sprawdzm czy mam dobre typy 7.3.5 Transpozycja DataFrame df_t_1 = pd.DataFrame([[1,&#39;a&#39;],[3,&#39;b&#39;]]) df_t_1_transpose = df_t_1.T # wykonanie transpozycji df_t_1_transpose type(df_t_1_transpose) # po transpozycji dalej to jest DataFrame df_t_1_transpose.dtypes # w wyniku transpozycji typu danych w obu kolumnach musialy byc zmienniony na &#39;object&#39; czyli tekst. 7.3.6 Zmiana nazw kolumn df_n = pd.DataFrame({&#39;d1&#39;:[1,2,3,4,5], &#39;d2&#39;:[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;], &#39;d3&#39;:[10,20,30,40,50]}) #(1) zmiana nazw wszystkich kolumn przez podanie listy nowych nazw df_n.columns = [&#39;col1&#39;,&#39;col2&#39;, &#39;col3&#39;] df_n #(2) zmiana nazw wybranych kolumn przez podanie słownika df_n = df_n.rename(columns = {&#39;col1&#39;:&#39;COL1&#39;,&#39;col2&#39;:&#39;COL2&#39;}) # zmiana nazwy kolumn &#39;co1&#39; i &#39;col2&#39; na &#39;COL1&#39; o &#39;COL2&#39; df_n #(3) zmiana nazw wybranych kolumn przez podanie pozycji kolumny df_n = df_n.rename(columns = {df_n.columns[1]:&#39;COL10&#39;}) # zmiana nazwy drugiej kolumny df_n 7.3.7 Usuwanie kolumn https://stackoverflow.com/questions/13411544/delete-column-from-pandas-dataframe-by-column-name df1 = pd.DataFrame({&#39;c1&#39;:[1,2,3,4,5], &#39;c2&#39;:[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;], &#39;c3&#39;:[10,20,30,40,50], &#39;c4&#39;:[1000,2000,3000,4000,5000] } ) #usuniecie jednej kolumny po nazwie df1 = df1.drop(&#39;c2&#39;, axis=1) df1 #d usuniecie kilku kolumn po nazwie df1 = df1.drop([&#39;c1&#39;,&#39;c3&#39;], axis=1) df1 # usuniecie kolumn po ich indeksach df1 = pd.DataFrame({&#39;c1&#39;:[1,2,3,4,5], &#39;c2&#39;:[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;], &#39;c3&#39;:[10,20,30,40,50], &#39;c4&#39;:[1000,2000,3000,4000,5000] } ) df1.drop(df1.columns[[0,1], axis=1) # usuwam kolumnę o indeksie 0 i 1. 7.3.8 Filtrowanie Data Frame - wybieranie kolumn import pandas as pd df_f = pd.DataFrame({&#39;wiek&#39;:[30,50,80, 70,40,20,50], &#39;imie&#39;:[&#39;Lukasz&#39;, &#39;Monika&#39;, &#39;Kasia&#39;, &#39;Asia&#39;, &#39;Basia&#39;, &#39;Zosia&#39;, &#39;Piotrek&#39; ], &#39;zawod&#39;:[&#39;prawnik&#39;, &#39;ekonomista&#39;, &#39;ekonomista&#39;, &#39;prawnik&#39;, &#39;prawnik&#39;, &#39;ekonomista&#39;, &#39;prawnik&#39;], &#39;staz&#39; : [10,20,10,30,20,40,20]} ) # wybor kolumny po indeksach df_f.iloc[:,[0,1]] # kolumna o indeksie 0 i 1 df_f[df_f.columns[-2:]] # dwie ostatnie kolumny df_f[df_f.columns[:2]] # dwie pierwsze kolumny df_f.iloc[:, [True, False, True, False]] # wyciagniecie kolumn w oparciu o wektor logiczny # Wybor kolumny po nazwach df_f[[&#39;wiek&#39;,&#39;zawod&#39;]] # podanie listy nazw # kolumny ktora maja nazwe zaczynajace sie od litery &#39;w&#39; df_f.loc[:, df_f.columns.str.startswith(&#39;w&#39;)] # kolumna ktore nazwa spelnia warunek zdefiniowany przez wyrazenie regularne df_f.filter(regex=r&#39;^wi&#39;, axis=1) # kolumny ktorych nazwy zaczynaja sie od liter &#39;wi&#39; # wybor kolumn ich typach danych df = pd.DataFrame({&#39;a&#39;: [1, 2] * 3, &#39;b&#39;: [True, False] * 3, &#39;c&#39;: [1.0, 2.0] * 3}) df.select_dtypes(include=&#39;bool&#39;) # wybierz wszystkie kolumny typu &#39;bool&#39; (typ logiczny) df.select_dtypes(include=[&#39;float64&#39;]) # wybierz wszystkie kolumny typu &#39;float64&#39; df.select_dtypes(exclude=[&#39;int&#39;]) # wybierz wszystkie kolumny z wykatkiem tych o typie &#39;int&#39; 7.3.9 Filtrowanie Data Frame - wybieranie wierszy #(1) PROSTE WYBIERANIE WIERSZY df_w = pd.DataFrame({&#39;wiek&#39;:[30,50,80, 70,40,20,50], &#39;imie&#39;:[&#39;Lukasz&#39;, &#39;Monika&#39;, &#39;Kasia&#39;, &#39;Asia&#39;, &#39;Basia&#39;, &#39;Zosia&#39;, &#39;Piotrek&#39; ], &#39;zawod&#39;:[&#39;prawnik&#39;, &#39;ekonomista&#39;, &#39;ekonomista&#39;, &#39;prawnik&#39;, &#39;prawnik&#39;, &#39;ekonomista&#39;, &#39;prawnik&#39;], &#39;staz&#39; : [10,20,10,30,20,40,20]} ) df_w[1:3] # wiersz o indeksie 1 i 2 (czyli wiersz drugi i trzeci) df_w[:3] # wiersze o indeksach od 1 do 2 df_w[4:] # wiersze o indeksach od 4 do ostatniego df_w.tail(n=2) # ostatnie 2 wiersze df_w.head(n=2) # pierwsze 2 wiersze df_w[::2]# wiersze nieparzyste df_w[1::2]# wiersze parzyste df_w.sample(3) # trzy losowe wiersze df_w.sample(frac=0.5) # wylosowanie 50% wierszy df_w[[True, False, True, True, False, True, True]] # kolumny po wektorze logicznym #(2) FILTROWANIE PO BARDZIEJ SKOMPLIKOWANYCH WARUNKACH df_w[df_w.wiek &gt; 30] df_w[df_w[&#39;wiek&#39;] &gt; 30] # to co wiersz wyzej, ale inna skladnia df_w[df_w.zawod == &#39;ekonomista&#39;] df_w[(df_w.wiek &gt; 30) &amp; (df_w.zawod == &#39;ekonomista&#39;)] df_w.query(&#39;wiek&gt;30 and zawod==&quot;ekonomista&quot;&#39;) # to co wiersz wyzej, ale inna skladnia 7.3.10 Dodawanie nowych kolumn df_w = pd.DataFrame({&#39;wiek&#39;:[30,50,80, 70,40,20,50], &#39;imie&#39;:[&#39;Lukasz&#39;, &#39;Monika&#39;, &#39;Kasia&#39;, &#39;Asia&#39;, &#39;Basia&#39;, &#39;Zosia&#39;, &#39;Piotrek&#39; ], &#39;zawod&#39;:[&#39;prawnik&#39;, &#39;ekonomista&#39;, &#39;ekonomista&#39;, &#39;prawnik&#39;, &#39;prawnik&#39;, &#39;ekonomista&#39;, &#39;prawnik&#39;], &#39;staz&#39; : [10,20,10,30,20,40,20]} ) # DODANIE KOLUMN CALKOWICIE NOWYCH df_w[&#39;zarobek&#39;] = [2000,1000,3000,1500,6000,3000,4000] # dodanie kolumny &#39;zarobek&#39; jako ostatniej kolumny df_w bonusy = [100,200,3000,150,500,300,400] df_w.insert(loc=2, column = &#39;bonusy&#39;, value = bonusy) # dodanie kolumny &#39;bonus&#39; tak aby miala indeks 2 (czyli byla trzecia kolumna) df_w tytul = [&#39;mgr&#39;, &#39;dr&#39;, &#39;dr&#39;, &#39;dr&#39;, &#39;dr&#39;, &#39;mrg&#39;, &#39;dr&#39;] df_w.insert(loc=list(df_w).index(&#39;zawod&#39;) + 1, column = &#39;tytul&#39;, value = tytul) # dodanie kolumny &#39;tytul&#39; tak aby byla po kolumnie &#39;zawod&#39; df_w # DODANIE KOLUMN W OPARCIU O WARUNKI LOGICZNE ZDEFINIONWA W OPARCIU O DOTYCHCZASOWE KOLUMNY # kategoria wiekowa - SPOSOB_1 df_w.loc[ df_w.wiek &lt; 40, &#39;Age Group&#39; ] = &#39;&lt; 40 yrs&#39; df_w.loc[ (df_w.wiek &lt;= 40) &amp; (df_w.wiek &lt; 50), &#39;Age Group&#39; ] = &#39;40-49 yrs&#39; df_w.loc[ df_w.wiek &gt;= 50, &#39;Age Group&#39; ] = &#39;50-59 yrs&#39; df_w # kategoria wiekowa - SPOSOB 2 def age_groups(series): if series &lt; 40: return &quot;&lt; 40 yrs&quot; elif 40 &lt;= series &lt; 50: return &quot;40-49 yrs&quot; elif 50 &lt;= series: return &quot;50-59 yrs&quot; df_w[&#39;Age Group&#39;] = df_w[&#39;wiek&#39;].apply(age_groups) df_w # czy osoba jest kobieta (na podstawie imienia) SPSOB 1 df_w.loc[ df_w.imie.isin([&#39;Monika&#39;, &#39;Kasia&#39;, &#39;Asia&#39;, &#39;Basia&#39;, &#39;Zosia&#39;]), &#39;czy_kobieta&#39; ] = True df_w.loc[ ~df_w.imie.isin([&#39;Monika&#39;, &#39;Kasia&#39;, &#39;Asia&#39;, &#39;Basia&#39;, &#39;Zosia&#39;]), &#39;czy_kobieta&#39; ] = False df_w # DODANIE NOWYCH KOLUMN WYLICZANYCH NA PODSTAWIE WARTOSCI ISTNIEJACYCH W ISTNIEJACYCH KOLUMNACH df_w.assign(zarobek_razy_10 = df_w.zarobek * 10) df_w.assign(temp_f=lambda x: x.zarobek * 10) # to co powyzej, ale inna skladnia df_w.assign(zarobek_proc_z_calosci = lambda x: x.zarobek / sum(df_w[&#39;zarobek&#39;])) # zarobek danej osoby jako procent z sumy wszystkich zarobkow df_w.assign(zarobek_plus_bonus = df_w[&#39;zarobek&#39;] + df_w[&#39;bonusy&#39;]) # suma bosu i zarobkow df_w[&#39;tytul_imie&#39;] = df_w[[&#39;tytul&#39;, &#39;imie&#39;]].apply(lambda x: &#39;_&#39;.join(x), axis=1) #skelenie kolumny &#39;tytul&#39; i &#39;imie&#39; # dodanie kolumny numerujacej wiersze (kolumna ma byc pierwsza kolumna) df_w.insert(0, &#39;ID&#39;, range(1, len(df_w) + 1) ) # dodanie kolumny numerujacej wiersze z przesunieciem numeracji df_w.insert(0, &#39;ID_2&#39;, range(10, len(df_w) + 10 )) # dodanie kolumny numerujace wiersze, ale numeracja jest grupowana po zmiennej &#39;zawod&#39; df_w[&#39;ID_group&#39;] = df_w.groupby([&#39;zawod&#39;]).cumcount() + 1 df_w # rozbicie kolumny na dwie kolumny. Rozbijam po myslniku df = pd.DataFrame({&#39;a&#39;:[&#39;aaa-aaaa&#39;,&#39;bbb-bbbbb&#39;]}) df[[&#39;split_1&#39;, &#39;split_2&#39;]] = df[&#39;a&#39;].str.split(&#39;-&#39;, n= 2, expand = True) df 7.3.11 Aktualizacja wartosci w kolumnach df_w = pd.DataFrame({&#39;wiek&#39;:[30,50,80, 70,40,20,50], &#39;imie&#39;:[&#39;Lukasz&#39;, &#39;Monika&#39;, &#39;Kasia&#39;, &#39;Asia&#39;, &#39;Basia&#39;, &#39;Zosia&#39;, &#39;Piotrek&#39; ], &#39;zawod&#39;:[&#39;prawnik&#39;, &#39;ekonomista&#39;, &#39;ekonomista&#39;, &#39;prawnik&#39;, &#39;prawnik&#39;, &#39;ekonomista&#39;, &#39;prawnik&#39;], &#39;staz&#39; : [10,20,10,30,20,40,20]} ) df_w.loc[0:2, &#39;wiek&#39;] = 20 # zmiana wartosci wieku na 20 dla 3 pierwszych wierszy df_w.loc[df_w.staz &gt; 20, &#39;wiek&#39;] = 30 df_w.loc[(df_w.staz &lt; 40) &amp; (df_w.zawod == &#39;ekonomista&#39;), &#39;wiek&#39;] = 50 7.3.12 Sortowanie df1 = pd.DataFrame({&#39;c1&#39;:np.array([1,2,3,4,5]), &#39;c2&#39;:[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;]}) df1.sort_values(by = [&#39;c1&#39;, &#39;c2&#39;], ascending=[False, True]) # posortowanie po kolumnach &#39;c1&#39; (malejaca) i c2 (rosnaco) 7.3.13 Bindowanie - w wierszach Uwaga. Przy bindowaniu po wiersza wystepuje niuanse zwiazane z indeksowanie. Patrz ‘Uwagi o indeksach’ w tym pliku w rozdziale o DataFrames Funkcja append import pandas as pd import numpy as np df1 = pd.DataFrame({&#39;c1&#39;:np.array([1,2,3,4,5]), &#39;c2&#39;:[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;]}) df2 = pd.DataFrame({&#39;c1&#39;:np.array([1,2,3,4,5]), &#39;c2&#39;:[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;]}) df3 = pd.DataFrame({&#39;d1&#39;:np.array([1,2,3,4,5]), &#39;d2&#39;:[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;]}) # zbondowanie DataFrame o tych samych kolumnach df12 = df1.append(df2) # dobindowanie do df1, DataFrame df3 o innych kolumnach df13 = df1.append(df3) # bdziemy miec kolumny z obu tabel. Braki beda uzupelnione wartosciami NaN # bindowanie do pustej DataFrame df0 = pd.DataFrame() df0.append(df1) # Uwaga. Funkcja append tak jak &#39;concat&#39; obsluguje argument &#39;ignore_indeks&#39; (Patrzy &#39;Uwagi o indeksach&#39; w tym pliku w rozdziale o DataFrames ) Funcja concat # Funkcja concat juz wczesniej wystepowala w naszych przykladach. # W porownaniu do funkcji &#39;append&#39; jest bardziej elastyczne bo mozemy ze jednym zamachem zbindowac cala liste DataFrames df1 = pd.DataFrame({&#39;c1&#39;:np.array([1,2,3,4,5]), &#39;c2&#39;:[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;]}) df2 = pd.DataFrame({&#39;c1&#39;:np.array([1,2,3,4,5]), &#39;c2&#39;:[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;]}) df3 = pd.DataFrame({&#39;d1&#39;:np.array([1,2,3,4,5]), &#39;d2&#39;:[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;]}) df123=pd.concat([df1, df2, df3]) 7.3.14 Bindowanie - w kolumnach Uwaga. Tutaj tez sa niuanse z indeksowaniem, jezeli tabele maja inne indeksy (Patrzy ‘Uwagi o indeksach’ w tym pliku w rozdziale o DataFrames ) df1 = pd.DataFrame({&#39;c1&#39;:np.array([1,2,3,4,5]), &#39;c2&#39;:[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;]}) df2 = pd.DataFrame({&#39;c1&#39;:np.array([1,2,3,4,5]), &#39;c2&#39;:[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;]}) df_c = pd.concat([df1, df2], axis=1) 7.3.15 Łączenie - merge Przyklady ze strony dokumentacji: https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.merge.html df1 = pd.DataFrame({&#39;lkey&#39;: [&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;, &#39;foo&#39;], &#39;value&#39;: [1, 2, 3, 5]}) df2 = pd.DataFrame({&#39;rkey&#39;: [&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;, &#39;foo&#39;], &#39;value&#39;: [5, 6, 7, 8]}) df1.merge(df2, left_on=&#39;lkey&#39;, right_on=&#39;rkey&#39;) # join po kluczu lkey (lewa tabela) i rkey(prawa tabela) 7.3.16 Praca z duplikatami # usuniecie duplikatow po wszystkich kolumnach df_d = pd.DataFrame({&#39;A&#39;:[1,1, 2,2] , &#39;B&#39;:[&#39;a&#39;,&#39;a&#39;, &#39;b&#39;,&#39;b&#39;]}) df_d.drop_duplicates() # usuniecie duplikatow po wybranych kolumnach df_d = pd.DataFrame({&#39;A&#39;:[1,1, 2,2, 3,3] , &#39;B&#39;:[&#39;a&#39;,&#39;a&#39;, &#39;b&#39;,&#39;b&#39;, &#39;c&#39;,&#39;d&#39;]}) df_d.drop_duplicates(subset=[&#39;A&#39;]) # uwudam duplikaty tylko po kolumnie &#39;A&#39; 7.3.17 Praca z brakami danych df_nan = pd.DataFrame({ &#39;wiek&#39;:[30,np.nan,80, np.nan,40,20,50] , &#39;imie&#39;:[&#39;Lukasz&#39;, &#39;Monika&#39;, &#39;Kasia&#39;, &#39;Asia&#39;, &#39;Basia&#39;, &#39;Zosia&#39;, &#39;Piotrek&#39; ] , &#39;zawod&#39;:[&#39;prawnik&#39;, &#39;ekonomista&#39;, &#39;ekonomista&#39;, &#39;prawnik&#39;, np.nan, &#39;ekonomista&#39;, &#39;prawnik&#39;] , &#39;staz&#39; : [10,20,10,30,20,40,np.nan]} ) # zliczenie brakow danych w kazdej KOLUMNIE oddzielnie df_nan.isna().sum() # zliczenie brakow danych w kazdym WIERSZU oddzielnie df_nan.isna().sum(axis=1) # zliczenie wszystkich brakow danych po wszysktich kelementach df_nan.isna().sum().sum() # usuniecie kazdego wiersza w ktorym jest JAKIKOLWIEK brak danych df_nan_1 = df_nan.dropna() df_nan_1 # usuniecie kazdego wiersza w ktorym jest brak danych ze względu na wybraną kolumnę df_nan_2 = df_nan.dropna(subset=[&#39;wiek&#39;]) df_nan_2 # zaimputowanie braku danych zadana wartoscia dla calego DataFrame df_nan_3 = df_nan df_nan_3.fillna(value = 0) # zaimputowanie braku danych zadana wartoscia dla wybranych kolumn df_nan_4 = df_nan df_nan_4[[&#39;wiek&#39;,&#39;staz&#39;]] = df_nan_4[[&#39;wiek&#39;,&#39;staz&#39;]].fillna(value = 0) #lub df_nan_4 = df_nan df_nan_4.fillna({&#39;staz&#39;:0, &#39;wiek&#39;:0}) # zaimputowanie braku danych wartoscia z POPRZEDNIEJ komorki df_nan_5 = df_nan df_nan_5.fillna(method = &#39;ffill&#39;) # zaimputowanie braku danych wartoscia z NASTEPNEJ komorki df_nan_6 = df_nan df_nan_6.fillna(method = &#39;bfill&#39;) # zaimputowanie brakow danych w calej DataFrame wartoscia srednia z kolumny &#39;staz&#39; df_nan_7 = df_nan df_nan_7.fillna(value = np.mean(df_nan_7.staz)) 7.3.18 Praca z wartosciami nieskonczonymi df_inf = pd.DataFrame({ &#39;wiek&#39;:[30,np.inf,80, np.inf,40,20,50] , &#39;staz&#39; : [10,20,10,30,20,40,-np.inf] , &#39;zarobek&#39;:[2000, np.inf, -np.inf, 3000, 5000, 2000, np.inf]} ) # zamiana wartosci plus_nieskoczone na 0 i minus_nieskoczone na -1 w kolumnach &#39;wiek i &#39;zarobek&#39; df_inf[[&#39;wiek&#39;,&#39;zarobek&#39;]] = df_inf[[&#39;wiek&#39;,&#39;zarobek&#39;]].replace([np.inf, -np.inf],[0, -1]) df_inf 7.3.19 Funkcje oknowe https://mode.com/blog/bridge-the-gap-window-functions #(1) wartosc kroczaca - przyklad dla sredniej df_rol_mean = pd.DataFrame({&#39;cena&#39;:[3,2,4,2,np.nan,np.nan,12,9,6,8,11]}) # szerokosc okna = 3; # minimalna ilosc dostepnych obserwacji w oknie zeby policzyc srednia = 2; df_rol_mean[&#39;cena_rolling_mean&#39;] = df_rol_mean[&#39;cena&#39;].rolling(window = 3, min_periods = 2 ).mean() df_rol_mean #(2) wartosc kroczaca - przyklad dla sredniej, ale tym razem GRUPOWANIE po zmiennej &quot;grupa&#39; df_rol_mean_group = pd.DataFrame({&#39;cena&#39;:[3,2,4,2,5,3,12,9,6,8,11], &#39;grupa&#39;:[&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;a&#39;,&#39;b&#39;,&#39;b&#39;,&#39;a&#39;,&#39;a&#39;,]}) df_rol_mean_group[&#39;cena_rol_mean_group&#39;] = df_rol_mean_group.groupby(&#39;grupa&#39;)[&#39;cena&#39;].rolling(window = 2).mean().reset_index(0, drop = True) df_rol_mean_group #(3) wartosci skumulowane - przyklad dla sredniej df_ex_mean = pd.DataFrame({&#39;cena&#39;:[3,2,4,2,np.nan,np.nan,12,9,6,8,11]}) df_ex_mean[&#39;cena_cummulative_mean&#39;] = df_rol_mean[&#39;cena&#39;].expanding().mean() #(3) wartosci skumulowane - przyklad dla sredniej, ale tym razem GRUPOWANIE po zmiennej &quot;grupa&#39; df_ex_mean_group = pd.DataFrame({&#39;cena&#39;:[3,2,4,2,5,3,12,9,6,8,11], &#39;grupa&#39;:[&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;a&#39;,&#39;b&#39;,&#39;b&#39;,&#39;a&#39;,&#39;a&#39;,]}) df_ex_mean_group[&#39;cena_rol_mean_group&#39;] = df_rol_mean_group.groupby(&#39;grupa&#39;)[&#39;cena&#39;].expanding().mean().reset_index(0, drop = True) df_ex_mean_group #(3) dodawanie numeracji wierszy - # przyklad jest w czesci &quot;Dodawanie nowych kolumn&quot; #(4) dodawanie rankingu wartosci - od razu przyklad z grupowaniem po zmiennej &#39;grupa&#39; df_dense_group = pd.DataFrame({&#39;cena&#39;:[3,2,4,2,5,3,12,9,6,8,11], &#39;grupa&#39;:[&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;a&#39;,&#39;b&#39;,&#39;b&#39;,&#39;a&#39;,&#39;a&#39;,]}) df_dense_group[&quot;cena_rank&quot;] = df_dense_group.groupby(&quot;grupa&quot;)[&quot;cena&quot;].rank(&quot;dense&quot;, ascending=False) # ranking typu &#39;dense&#39; #(4) shift/lag - czyli przesuniecia wartosci w kolumnach df_shift = pd.DataFrame({&#39;cena&#39;:[3,2,4,2,5,3,12,9,6,8,11], &#39;grupa&#39;:[&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;a&#39;,&#39;b&#39;,&#39;b&#39;,&#39;a&#39;,&#39;a&#39;,]}) df_shift[&#39;cena_shift_2&#39;] = df_shift[&#39;cena&#39;].shift(periods = 2, fill_value = 0) # zmienna &#39;cena&#39; przesunietaW DOL o 2 pozycje. Powstale puste miejsca sa wypelnione zerami. df_shift df_shift[&#39;cena_shift_minus_2&#39;] = df_shift[&#39;cena&#39;].shift(periods = -2, fill_value = 0) # zmienna &#39;cena&#39; przesunieta W GORE o 2 pozycje. Powstale puste miejsca sa wypelnione zerami. df_shift #(5) shift/lag - czyli przesuniecia wartosci w kolumnach (tym razem z grupowaniem po zmiennej &#39;grupa&#39;) df_shift_grupa = pd.DataFrame({&#39;cena&#39;:[3,2,4,2,5,3,12,9,6,8,11], &#39;grupa&#39;:[&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;a&#39;,&#39;b&#39;,&#39;b&#39;,&#39;a&#39;,&#39;a&#39;,]}) df_shift_grupa[&#39;cena_shift_grupa&#39;] = df_shift_grupa.groupby([&#39;grupa&#39;])[&#39;cena&#39;].shift(periods = 1) df_shift_grupa # identyfikator grupowy - grupe identyfikuje po tej samej plci i tytule. Chce aby grupy dostaly kolejne numerki (czyli np. kobieta magister to grupa 2) df_group_id = pd.DataFrame({&#39;cena&#39;:[2,1,3,4,3,2,1,3,4] ,&#39;plec&#39;:[&#39;k&#39;,&#39;k&#39;,&#39;m&#39;,&#39;m&#39;,&#39;k&#39;,&#39;m&#39;,&#39;k&#39;,&#39;k&#39;,&#39;m&#39;] ,&#39;tytul&#39;:[&#39;mgr&#39;,&#39;dr&#39;,&#39;mgr&#39;,&#39;mgr&#39;,&#39;dr&#39;,&#39;mgr&#39;,&#39;mgr&#39;,&#39;dr&#39;,&#39;mgr&#39;]}) df_group_id[&#39;GrpIdx&#39;] = df_group_id.groupby([&#39;plec&#39;,&#39;tytul&#39;]).grouper.group_info[0] df_group_id 7.3.20 Praca z GroupBy df = pd.DataFrame({&#39;a&#39;:[1,1,1,2,2,2], &#39;b&#39;:[1,1,1,1,1,1], &#39;c&#39;:[10,10,10,10,10,10] }) df.groupby(&#39;a&#39;)[&#39;b&#39;].sum() # suma po kolumnie &#39;b&#39; grupowana po kolumnie &#39;a&#39; df.groupby(&#39;a&#39;)[&#39;b&#39;].agg(&#39;sum&#39;) # suma po kolumnie &#39;b&#39; grupowana po kolumnie &#39;a&#39; (inna skladnia) df.groupby(&#39;a&#39;)[[&#39;b&#39;,&#39;c&#39;]].agg(&#39;sum&#39;) # suma po kolumnie &#39;b&#39; i &#39;c&#39; grupowana po kolumnie &#39;a&#39; df.groupby(&#39;a&#39;)[&#39;b&#39;].agg([&#39;sum&#39;, &#39;min&#39;]) # suma i minimum po kolumnie &#39;b&#39; # different aggreagation per column df.groupby(&#39;a&#39;).agg({&#39;b&#39;:[&#39;sum&#39;,&#39;min&#39;], &#39;c&#39;:[&#39;sum&#39;]}) # suma i minimum po kolumnie &#39;b&#39; oraz tylko suma po kolumnie &#39;c&#39; (grupowanie po kolumnie &#39;c&#39;) # uzycie funkcji anonimowej df.groupby(&#39;a&#39;).agg({&#39;b&#39;:lambda x:x.std(ddof=1)}) # obliczam odchylenie standardowe dla kolumny b 7.3.21 Funkcje po kolumnach i wierszach 7.3.21.1 apply Apply a function along an axis of the DataFrame. 7.3.21.2 operacje na wszystkich elementach df1 = pd.DataFrame([[4, 2], [4, 2]], columns=[&#39;A&#39;, &#39;B&#39;]) import numpy as np df1.apply(np.sqrt) # spierwiastkowanie wszystkich elementow ramki danych df2 = pd.DataFrame([[4, 2, &#39;a&#39;], [4, 2, &#39;b&#39;]], columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]) df2.apply(np.sqrt) # spierwiastkowanie wszystkich elementow ramki danych - dostaniemy blad bo jedna z kolumn to string i jest niepierwiastkowalna # skladnia z funkcja anonimowa df2.apply() 7.3.21.3 operacje wzdloz osi df3 = pd.DataFrame([[4, 2], [4, 2]], columns=[&#39;A&#39;, &#39;B&#39;]) df3.apply(np.sum, axis = 0)# zsumowanie po kolumnach (w dol) df3.apply(np.sum, axis = 1)# zsumowanie po wierszach ( prawo) 7.3.21.4 lambda-przyklady df1 = pd.DataFrame([[1, 2, 6], [1, 2, 6], [1, 2, 6]], columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]) df1.apply(lambda x: x**2) # pdniesienie do kwadratu wszysktich elemenotow df1.apply(lambda x: sum([x[0], x[1]]) , axis = 1) # sumu wiersza, ale wuzgledniajac tylko kolumny i indeksach 0 i 1. 7.3.21.5 problem zwracania wektorow przez operacja df1 = pd.DataFrame([[1, 2], [5, 6]], columns=[&#39;A&#39;, &#39;B&#39;]) # w tej opracji dla kazdej komorki dostajemy wektor df1.apply(lambda x: [x[0], x[0]+1], axis=1) # co zrobic zeby wektor byl rozbity na oddzielne kolumny? df1.apply(lambda x: [x[0], x[0]+1], axis=1, result_type = &#39;expand&#39;) 7.3.22 Praca z tekstem df = pd.DataFrame({&#39;a&#39;:[&#39;aaa-aa-aa&#39;,&#39;bbb-bbbb-b&#39;]}) # split - rozbicie df[&#39;split_2&#39;] = df[&#39;a&#39;].str.split(&#39;1-&#39;) # rozbicie ale alementy rozbite sa zagniezdzona w komorce lista. pd.concat([df, df[&#39;a&#39;].str.split(&#39;-&#39;, n=3, expand = True)]) # sztywnie ograniczam ze maja byc 3 nowe kolumny po slicie. pd.concat([df, df[&#39;a&#39;].str.split(r&#39;[0-9]&#39;, expand = True)]) # # sklejenie po wierszach df = pd.DataFrame({&#39;a&#39;:[&#39;A&#39;,&#39;B&#39;], &#39;b&#39;:[&#39;C&#39;,&#39;D&#39;]}) df[&#39;paste&#39;] = df[[&#39;a&#39;, &#39;b&#39;]].apply(lambda x: &#39;&#39;.join(x), axis=1) # sklejanie po kolumnie z grupowaniem df = pd.DataFrame({&#39;a&#39;:[&#39;A&#39;,&#39;A&#39;,&#39;B&#39;,&#39;B&#39;], &#39;b&#39;:[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]}) df.groupby(&#39;a&#39;)[&#39;b&#39;].agg(lambda col: &#39;&#39;.join(col)) df1 = df1.assign(d = df1[&#39;c2&#39;].str.upper()) df.assign(temp_f=lambda x: x.temp_c * 9 / 5 + 32) df1.assign(e = df1[&#39;c2&#39;] + df1[&#39;d&#39;]) 7.3.23 Praca z datami Uwaga: tutaj jest tylko o datach w kontekscie skladni DataFrame. Wiecej informacji o datach jest w dedykowanym rozdziale. Ekstrakcja czesci daty import dateutil # glowny pakiet do bardziej zaawansowanych operacji na datach import datetime import pandas as pd # tworze DataFrame z dwoma datami data = pd.DataFrame( {&#39;data&#39;:pd.Series([datetime.date(2010, 1, 2), datetime.date(2010, 1, 20)], dtype=&#39;datetime64[ns]&#39;)} ) data data.dtypes # dodaje kolumny w ktorych sa pobrane kolejne czesci dat w kolumnie &#39;daty&#39; data[&#39;year&#39;] = pd.DatetimeIndex(data[&#39;data&#39;]).year data[&#39;month&#39;] = pd.DatetimeIndex(data[&#39;data&#39;]).month data[&#39;hour&#39;] = pd.DatetimeIndex(data[&#39;data&#39;]).hour data # lista innych (poza pokazanym year, month, hour) dostepnych interwalow czasowych do zobaczenia w tabelce &quot;Attributes&quot; na stronie dokumentacji DatatimeIndex: https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DatetimeIndex.html Inkrementacja daty data = pd.DataFrame( {&#39;data&#39;:pd.Series([datetime.date(2010, 1, 2), datetime.date(2010, 1, 20)], dtype=&#39;datetime64[ns]&#39;)} ) # UWAGA: ponizsze przyklady z funkcja &#39;to_timedelta&#39; na razie zakomentowana bo nie do konca podoba mi sie ich dzialanie. Rekomenduje uzycue funkcji relativedelta co niestety wymaga zastosowania nieco mniej przyjaznej skladni # data[&#39;data_plus_5_M&#39;] = (pd.to_datetime(data[&#39;data&#39;])) + pd.to_timedelta(5.0,unit=&#39;M&#39;) # zwiekszam date o 5 miesiecy # # data[&#39;data_minus_3_M&#39;] = (pd.to_datetime(data[&#39;data&#39;])) + pd.to_timedelta(-3,unit=&#39;M&#39;) # zmniejszam date o 3 miesiece # # data[&#39;data_minus_3_M&#39;] = (pd.to_datetime(data[&#39;data&#39;])) + pd.to_timedelta(-3,unit=&#39;W&#39;) # zmiejszam date o 3 tygodnie # Mozliwe wartosci dla parametru &#39;unit&#39; to: # (‘Y’, ‘M’, ‘W’, ‘D’, ‘days’, ‘day’, ‘hours’, hour’, ‘hr’, ‘h’, ‘m’, ‘minute’, ‘min’, ‘minutes’, ‘T’, ‘S’, ‘seconds’, ‘sec’, ‘second’, ‘ms’, ‘milliseconds’, ‘millisecond’, ‘milli’, ‘millis’, ‘L’, ‘us’, ‘microseconds’, ‘microsecond’, ‘micro’, ‘micros’, ‘U’, ‘ns’, ‘nanoseconds’, ‘nano’, ‘nanos’, ‘nanosecond’, ‘N’) # skladania z uzyciem funkcji z pakietu &#39;dateutil&#39; ( na razie bardziej rekomendowana) data[&#39;data_minus_3_M_dateutil&#39;] = list(map(lambda x: x + dateutil.relativedelta.relativedelta(months=-3) ,pd.to_datetime(data.data))) #lub data[&#39;data_minus_3_M_dateutil&#39;] = data.apply(lambda x: x[&#39;data&#39;] + dateutil.relativedelta.relativedelta(months=-3), axis=1) Roznice miedzy datami import datetime data = pd.DataFrame( {&#39;data_1&#39;:pd.Series([datetime.date(2010, 1, 2), datetime.date(2010, 1, 20)], dtype=&#39;datetime64[ns]&#39;) , &#39;data_2&#39;:pd.Series([datetime.date(2011, 1, 2), datetime.date(2009, 1, 20)], dtype=&#39;datetime64[ns]&#39;)} ) data[&#39;data_diff_m&#39;] = (pd.to_datetime(data[&#39;data_1&#39;]) - pd.to_datetime(data[&#39;data_2&#39;]) )/np.timedelta64(1,&#39;M&#39;) # roznica w miesiacach data[&#39;data_diff_y&#39;] = (pd.to_datetime(data[&#39;data_1&#39;]) - pd.to_datetime(data[&#39;data_2&#39;]) )/np.timedelta64(1,&#39;Y&#39;) # roznica w latach data[&#39;data_diff_w&#39;] = (pd.to_datetime(data[&#39;data_1&#39;]) - pd.to_datetime(data[&#39;data_2&#39;]) )/np.timedelta64(1,&#39;W&#39;) # roznica z weekendach data[&#39;data_diff_w&#39;] = (pd.to_datetime(data[&#39;data_1&#39;]) - pd.to_datetime(data[&#39;data_2&#39;]) )/np.timedelta64(1,&#39;D&#39;) # roznica w dniach Zaokraglanie dat #(1) zaokrlaglanie do pierwszego/ostatniego dnia miesiaca #data frame import datetime data = pd.DataFrame( {&#39;data&#39;:pd.Series([datetime.date(2010, 1, 2), datetime.date(2010, 1, 20)], dtype=&#39;datetime64[ns]&#39;)} ) data[&#39;data_round&#39;] = pd.to_datetime(data[&#39;data&#39;]) + pd.offsets.MonthBegin(0) # zaokrlaglad do pierwszego dnia miesiaca data[&#39;data_round2&#39;] = pd.to_datetime(data[&#39;data&#39;]) + pd.offsets.MonthBegin(4) # dodaje 4 miesiace i zaokrlaglam do pierwszego dnia miesiaca data[&#39;data_round3&#39;] = pd.to_datetime(data[&#39;data&#39;]) + pd.offsets.MonthEnd(4) # dodaje 4 miesiacae i zakraglam do ostatniego dnia miesiaca data[&#39;data_round4&#39;] = pd.to_datetime(data[&#39;data&#39;]) + pd.offsets.MonthEnd(4) # dodaje 4 miesiacae i zakraglam do ostatniego dnia miesiaca data[&#39;data_round5&#39;] = pd.to_datetime(data[&#39;data&#39;]) + pd.offsets.YearBegin(0) # zakraglam do pierwszego dnia roku # Lista dostepnych zaokraglen na stronie dokumentacji: https://pandas.pydata.org/pandas-docs/stable/reference/offset_frequency.html 7.3.24 Dummy - rekodowanie na zmienne zero-jedynkowe # tworze DataFrame ze zmienna jakosciowa df_dummy = pd.DataFrame({&#39;wyksztalcenie&#39;:[&#39;podstawowe&#39;,&#39;srednie&#39;,&#39;wyzsze&#39;,&#39;doktorat&#39;]}) df_dummy = pd.get_dummies(df_dummy[&#39;wyksztalcenie&#39;]) # zmienna jakosciowa &#39;wyksztalcenie&#39; zostanie przeksztalcona na 4 zmiennej zero-jedynkowe (jedna kolumna dla kazdej kategorii zmiennej) 7.3.25 crosstab - analiza liczebnosci https://pbpython.com/pandas-crosstab.html import pandas as pd df = pd.DataFrame({ &#39;A&#39;:pd.Categorical([&#39;a&#39;, &#39;b&#39;,&#39;a&#39;,&#39;a&#39;,&#39;b&#39;]) , &#39;B&#39;:pd.Categorical([&#39;d&#39;, &#39;e&#39;,&#39;e&#39;,&#39;e&#39;,&#39;f&#39;])}) pd.crosstab(df.A, df.B) pd.crosstab(df.A, df.B, normalize = &#39;columns&#39;) # procentowy udzial liczebnosci w kolumnie ( w kolumnie sumuje się do 100%) pd.crosstab(df.A, df.B, normalize = &#39;index&#39;) # procentowy udzial liczebnosci w wirszu ( w wierszu sumuje się do 100%) pd.crosstab(df.A, df.B, normalize = &#39;all&#39;) # procentowy udzial liczebnosci w calosci (po wszystkim sumuje się do 100%) # kiedy mamy wiecej niz dwie kategorie trzeba dokonac grupowania, czyli wprowadzic hierarchie df2 = pd.DataFrame({ &#39;A&#39;:pd.Categorical([&#39;a&#39;, &#39;b&#39;,&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;a&#39;]) , &#39;B&#39;:pd.Categorical([&#39;d&#39;, &#39;e&#39;,&#39;e&#39;,&#39;d&#39;,&#39;d&#39;,&#39;e&#39;]) , &#39;C&#39;:pd.Categorical([&#39;w&#39;, &#39;w&#39;,&#39;w&#39;,&#39;z&#39;,&#39;z&#39;,&#39;z&#39;])}) # zrobimy jedna zmienna w wierszy i 2 w kolumnach. Te kolumnowe trzeba zagnieździc pd.crosstab(df2.A, [df2.B, df2.C] )# w kolumnach mamy tabele po zmiennej B i C z tymże kategorie dla C są zagnieżdżone w kategoriach dla B # teraz zrobimy to samo, ale dodamy recznie nazwy dla wynikowej tabeli pd.crosstab(df2.A, [df2.B, df2.C] , rownames=[&#39;zmienna_A&#39;], colnames=[&#39;zmienna_B&#39;,&#39;zmienna_C&#39;]) 7.3.26 zmiana struktury DataFrame melt - Zmiana z formatu szerokiego (wide) na dlugi (long) import pandas as pd # mamy dane w formacie krotkim gdzie przyjmujemy ze mamy 2 grupujace zmienne jakosciowe (plec i zawod;): df_wide = pd.DataFrame({&#39;plec&#39;:[&#39;k&#39;, &#39;m&#39;, &#39;m&#39;, &#39;m&#39;, &#39;k&#39;, &#39;k&#39;, &#39;m&#39; ] , &#39;zawod&#39;:[&#39;prawnik&#39;, &#39;ekonomista&#39;, &#39;ekonomista&#39;, &#39;prawnik&#39;, &#39;prawnik&#39;, &#39;ekonomista&#39;, &#39;prawnik&#39;] , &#39;wiek&#39;:[30,50,80, 70,40,20,50] , &#39;staz&#39; : [10,20,10,30,20,40,20]} ) df_wide # wydluzamy dane wrzucajac zmienne niegrupujace, czyli &#39;wiek&#39; i &#39;staz&#39; do jednej kolumny (przetapiajac dane) df_long = df_wide.melt(id_vars=[&#39;zawod&#39;,&#39;plec&#39;], value_vars=[&#39;wiek&#39;,&#39;staz&#39;]) df_long pivot Tu jest miejsce Asiu, dla Ciebie :) pivot_table Jest dobry manual na stronie: https://pandas.pydata.org/pandas-docs/stable/user_guide/reshaping.html import pandas as pd # utworzenie zbioru danych z trzeba kolumnami df = pd.DataFrame({&#39;Imie&#39;: [&#39;John&#39;, &#39;John&#39;, &#39;Mina&#39;, &#39;Peter&#39;, &#39;Nicky&#39;,&#39;John&#39;, &#39;Boby&#39;, &#39;Mina&#39;, &#39;Peter&#39;, &#39;Nicky&#39;, &#39;Peter&#39;, &#39;Nicky&#39;, &#39;Mina&#39;, &#39;Mina&#39; ], &#39;Tytul&#39;: [&#39;Masters&#39;, &#39;Graduate&#39;, &#39;Graduate&#39;, &#39;Masters&#39;, &#39;Graduate&#39;,&#39;Masters&#39;, &#39;Graduate&#39;, &#39;Graduate&#39;, &#39;Masters&#39;, &#39;Graduate&#39;, &#39;Masters&#39;, &#39;Graduate&#39;, &#39;Masters&#39;, &#39;Graduate&#39;], &#39;Stanowisko&#39;:[&#39;Specialist&#39;, &#39;Analyst&#39;,&#39;Specialist&#39;, &#39;Analyst&#39;,&#39;Specialist&#39;, &#39;Analyst&#39;,&#39;Specialist&#39;, &#39;Analyst&#39;,&#39;Specialist&#39;, &#39;Analyst&#39;, &#39;Analyst&#39;, &#39;Analyst&#39;, &#39;Analyst&#39;, &#39;Analyst&#39;], &#39;Punkty&#39;:[27, 23, 50, 23, 24,27, 23, 30, 23, 24, 30, 22, 19, 28], &#39;KPI&#39;:[10,20,15,10,20,15,10,20,15,10,20,15,10,20]}) import numpy as np # wartosci z kolumny &#39;Punkty&#39; i &#39;KPI&#39; zsumuje i usrednimy wierszowo po zmiennych &#39;Imieniu&#39; i &#39;Tytule&#39; i kolumnowo po zmiennej &#39;Stanowisko&#39;. Dodatkowo dla konfiguracji dla ktorych nie ma wartosci robie wypelnienie wartosciami &#39;-1&#39; table = pd.pivot_table(df , values = [&#39;Punkty&#39;,&#39;KPI&#39;] , index = [&#39;Imie&#39;, &#39;Tytul&#39;] , columns =[&#39;Stanowisko&#39;] , aggfunc = [np.sum, lambda x:x.mean.round] # stosujemy 2 operacje: suma i srednia. Wyniki ze sredniej sa dodatkowo zaokraglone , fill_value = -1) table # UWAGA: niestety obecnie funkcja &#39;pivot_table&#39; nie daje mozliwosci robienia &#39;subtotals&#39; czyli zagniezdzonych sum po kategoriach. 7.3.27 Rozne problemy 7.3.27.1 Uzupelnianych kategorii Problem. W kolumnach ‘marka’ i ‘typ’ są marki samochodow i typu nadwozia (sedan, kabriolet itp.) W finalnej tabeli okazuje się że nie występują wszystkie możliwe kombinacje w danych (np. np. Mercedesa ktory jest kabrioletem) Chcemy takie brakujące kombinacje dodać i wypełnić pozostałe kolumny np. braki danych. To się często przydaje przy raportach, kiedy chcemy aby wszystkie kombinacje kategorii były wyświetlone w raporcie dla managera. Problem może też dotyczyć dziur w datach dla poszczegolnych kategorii. Taki przyklad przerobimy ponizej (skopiowane ze stackoverflow) import itertools # zmienne ktorych kominacje chcemy miec z komplecie person_id = [0, 1, 2] status = [&#39;pass&#39;, &#39;fail&#39;,&#39;pass&#39;] year = [1980, 1981, 1982] # inna zmienna ktora bedzie wypelnona zerami po dodaniu brakujacych kombinacji count = [3,4,8] #tabela wyjsciowa gdzie sa tylko 3 kombinacje zmiennych df_1 = pd.DataFrame({&#39;person_id&#39;:person_id, &#39;status&#39;:status, &#39;year&#39;:year, &#39;count&#39;:count}) combined = [person_id, status, year] df_full_kombinacje = pd.DataFrame(columns = [&#39;person_id&#39;, &#39;status&#39;, &#39;year&#39;], data=list(itertools.product(*combined))) # dodanie zmienej count i uzupelnienie brakow zerami df_new_full_table = df_full_kombinacje.merge(df_1, how=&#39;left&#39;).fillna(0) df_new_full_table "],
["data-structures-numpy-scipy.html", "Chapter 8 DATA STRUCTURES - Numpy, Scipy 8.1 Numpy 8.2 Scipy", " Chapter 8 DATA STRUCTURES - Numpy, Scipy 8.1 Numpy Fajny cheat sheet do Nympy https://s3.amazonaws.com/assets.datacamp.com/blog_assets/Numpy_Python_Cheat_Sheet.pdf 8.1.1 Tworzenie import numpy as np #(1) z definicji # jednowymiarowa macierz np.array([1,2,3,4]) # tak jak przy DataFrames, tworzymy dwuwymiarową macierz podajac kolejno elementy wiersza a nie kolumny: np.array( [[1,2], [3,4]] ) # wartosci 1 i 2 to bedzie pierwszy wiersza a nie kolumna # wymusze typu danych (w przykladnie na typ &#39;string&#39; a = np.array([1,2,3], dtype=&#39;str&#39;) # UWAGA -to nie jest Pandas wiec tekst to nie typ &#39;object&#39;, ale tak jak w całym Pythonie &#39;str&#39; # macierz wielowymiarowa a_w = np.array([[[1,2,3], [1,2,3], [1,2,3]], [[1,2,3], [1,2,3], [1,2,3]], [[1,2,3], [1,2,3], [1,2,3]]]) # macierz 3 wymiarowa (3x3x3 elementow) a_w.ndim # macierz ma 3 wymiary #(2) z listy l1 = [1,2,3,4] np.array(l) l2 = [1, &#39;a&#39;] a = np.array(l2) # macierz musi byc jednorodna pod wzgledem typu, wiec liczba 1 zostala przekonwertowana na tekst a.dtype # typ U11 oznacza ze &quot;All the elements got converted into a string&quot; #(3) z DataFrame import pandas as pd df = pd.DataFrame([[1,2],[3,4]], columns = [&#39;A&#39;, &#39;B&#39;]) # sposob 1 a1 = df.as_matrix(columns=[&#39;A&#39;, &#39;B&#39;]) # tutaj mozemy wybierac kolumny # sposob 2 a2 = np.asmatrix(df, dtype = &#39;str&#39;) # tutaj jest mozliowosc wymuszenia typu # sposob 3 a3 = np.asarray(df, dtype = &#39;str&#39;) # tutaj jest mozliowosc wymuszenia typu #(4) tworzenie specyficznych macierzy a = np.array([1,2,3,4]) np.zeros_like(a) # tworze macierz o takich samych rozmwiarach jak macierz &#39;a&#39; ale wypelniam wszystko ZERAMI np.ones_like(a) # tworze macierz o takich samych rozmwiarach jak macierz &#39;a&#39; ale wypelniam wszystko JEDYNKAMI np.empty(shape=[3,3], dtype=&#39;str&#39;) # utworzenie pustej tabeli typu &#39;str&#39; (tekst) np.empty(shape=[3,3], dtype=&#39;int&#39;) # utworzenie tabeli typu &#39;int&#39; - bedzie wypelniona losowymi wartosciami np.zeros(shape=[3,3]) # utworzenie pustej tabeli o wymiarach 3X3 wypelnionej zerami np.ones(shape=[3,3]) # utworzenie pustej tabeli o wymiarach 3X3 wypelnionej jedynkami np.full(shape=[3,3], fill_value=10) # utworzenie pustej tabeli o wymiarach 3X3 wypelnionej liczba 10. 8.1.2 atrybuty Macierze przechowuja dane jednorodne. W macierze (w przeciwienstwie np. do list) nie moze byc dwoch typow danych na raz (np. liczba i tekst) import numpy as np #(1) jednorodnosc typu # jezeli kolumny sa roznego typu to tak jak przy pistach sie je ujednoradnia df2 = pd.DataFrame([[1,&#39;2&#39;],[3,&#39;4&#39;]]) # pierwsza kolumna to liczba a druga to tekst a2 = df2.as_matrix() # wszystko zostal zamienione na tekst a2[:,0] # podglad pierwszej kolumny przekonwertowanej na tekst #(2) inne atrybuty a = np.array([[1,2],[3,4]]) a.ndim # ilosc wymiarow a.shape # rozmiary a.size # ilosc elementow a.dtype # typ przechowywanych danych 8.1.3 odwolywanie sie przez indeksy Dla macierzy jednowymiarowych sytuacja jest tak jak przy listach. Macierze dwuwymiarowe # tworze macierz o wymiarach 4x3 (4 wiersze, 3 kolumny) a = np.array([[1,2,3],[4,5,6],[7,8,9],[10,11,12]]) a[1,1]# piersze komorka (pierwszy wiersz, pierwsza kolumn) a[:,0] # pierwsza kolumna a[0,:] # pierwszy wiersz a[1:,:] # od drugiego wiersza w dol a[:,1:] # od drugiej kolumny w dol a[:,a.shape[1]-1 ] # ostatnia kolumna a[a.shape[0]-1, : ] # ostatni wiersz Macierze wielowymiarowe # tworze macierz o wymiarach 2x2x2 a = np.array([[1,2],[3,4]],[[5,6],[7,8]]) # dołożenie nowych wymiarow powoduje ze dostajemy kolejny ineks. Kolejny indeks jest dokladany z lewej strony (po zobaczeniu przykadlwo zrozumiesz o co chodzi zo dokladaniem po lewej: # mamy jeden wymiar a=np.array([1,2,3]) a[2] # dostaje drugi element (druga kolumna jezeli traktowa to jako macierz o wymiarach 1X3) # dokladam wymiar drugi a=np.array([[1,2,3], [3,4,5]]) a[3,2] # wartosc 2 odwoluje sie dalej do drugiej KOLUMNY (ale jest to juz nie wymiar o indeksie 0 ale wymiar o indeksie 1, bo zostal przesuniety w prawo). Nowy wymiar jest po lewej stronie i on leci po nowym wymiarze o indeksie 1 (wiersze) # dokladam trzeci wymiar a=np.array([[[1,2,3], [3,4,5]], [[6,7,8],[9,10,11]]]) a[1,3,2] # nowy wymiar (plastry trojwymiarowej macierzy) jest dolozony po lewej stronie (w przykladnie wartosc 1) # graficzne podsumowanie tej logiki wymiarow na rysunku: https://www.google.com/search?q=numpy+array&amp;tbm=isch&amp;source=iu&amp;ictx=1&amp;fir=uiZt51tvuJE1PM%253A%252C1A3kHFAoV2Q2XM%252C_&amp;vet=1&amp;usg=AI4_-kRLpak4KNy8fqWXrsph4EYf_EkHPQ&amp;sa=X&amp;ved=2ahUKEwi-7frq4PziAhWR7KYKHdw9BeIQ9QEwAHoECAIQAw#imgrc=3MW07qtoURqTWM:&amp;vet=1 # przyklady uzywanie powyzszej reguly (Asiu, ja tak na 90% jestem pewien poprawnosci ponizszego nazewnictwa :). Zaladam ze nowy (trzeci) wymiar doklada plasterki w dol (jak warstwy na torcie), a nie w tyl (jak ksiazki na polce) ) a[:,:,2] # tyl macierzy a[:,:,0] # czolo macierzy a[0:,:,:] # dach macierzy (gorny plaster) a[2:,:,:] # spod macierzy (dolny plaster) a[:,0,:] # bok macierzy (lewy) a[:,2,:] # bok macierzy (prawy) 8.1.4 filtrowanie a = np.array([[1,2,3],[4,5,6]]) a[np.where(a&gt;2)] # wartosci wieksze od 2. Macierz nie jest juz kwadratowa tylo jest wektorem. a.diagonal() # elementy diagonalne 8.1.5 aktualizacja wartosci a = np.array([[1,2,3],[4,5,6]]) a[:,1] = np.array([10,20]) # zmieniam druga kolumne a 8.1.6 usuwanie a=np.array([[[1,2,3], [4,5,6]], [[7,8,9],[10,11,12]]]) a # usuwanie elementow tak zeby zachowac ksztalt macierzy (wycinamy cale plastry) np.delete(arr=a, obj=(1), axis= 0) # dla wymiaru 0 wycinam dla niego wszytko co ma indeks 1. np.delete(arr=a, obj=(0,1), axis= 1) # dla wymiaru 1 wycinam dla niego wszytko co ma indeks 0 i 1. np.delete(arr=a, obj=np.s_[0:1], axis= 1) #to co linijka wyzej ale skladnia umowliziwajace poslugowaniem sie logika indeksow przy definiowaniu elementow do usuniecie 8.1.7 zmiana kszatłtu i transpozycja Transpozycja #(1) transpozycja macierzy kwadratowej a = np.array([[1,2],[3,4]]) a.transpose() #(2) transpozycja macierzy wielowymiarowych a=np.array([[[1,2,3], [4,5,6]], [[7,8,9],[10,11,12]]]) a np.transpose(a, axes=(1,0,2) ) # wymiary teraz maja byc w kolejnosci: wymiar pierwszy jako drugi, drugi jako pierwszy, a trzeci zostaje na swoim miejscu Zmiana ksztaltu # macierz o wymiarach 2x6 (2 wiersze , 6 kolumn) a = np.array([[1,2,3,4,5,6],[7,8,9,10,11,12]]) a a.shape # podstawowy reshape a1 = a.reshape((6,2)) # zmiana wymiarow z 6x2 na 2x6. a1 a1.shape # reshape z innych schematem kolejnosci elementow a2 = a.reshape((6,2), order=&#39;F&#39;) # zmiana wymiarow z 6x2 na 2x6. Ale tutaj otrzymujemy inna kolejnosc elementow. W pierwszym wierszu mamy element w pierwszy pierwszego starego wiersza i element pierwszy drugiego starego wiersza a2 a2.shape 8.1.8 bindowanie import numpy as np # (1) przyklad macierzy dwuwymiarowych # doklejenie do macierzy 2X3 nastepnej macierzy 2X2 a1=np.array([[1,2,3], [3,4,5]]) a2=np.array([[10,20,30], [30,40,50]]) np.append(a1, a2, axis=0) # sklejenie maciarzy jedna pod druga np.append(a1, a2, axis=1) # sklejenie maciarzy jedna obok drugie #(3) Macierze wielowymiarowe a1 = np.array([[[1,2],[3,4]], [[5,6],[7,8]]]) # macierz 2x2X2 a2 = np.array([[10,20],[30,40]]) # macierz 2X2 (plaserek w przestrzni trojwymiarowe) # macierz a2 ma za malo wymiarow (dwa, a macierz a1 ma trzy. Musimy zrobic plasterek 2X2 z trzecim wymiarem (dodobic 3 indeks) a3 = a2.reshape((1,2,2)) np.append(a1, a3, axis = 0) # doklejenie w dol np.append(a1, a3, axis = 1) # doklejenie w bok - tutaj blad bo nie pasuja rozmary np.append(a1, a3.transpose((1,0,2)), axis = 1) # doklejenie w bok - teraz pasuje bo odopowiednie przetransponowalismy doklejany do macirzy a1 plasterek a3 np.append(a1, a3, axis = 2) # doklejenie w tyl - ale znowu blad np.append(a1, a3.transpose((1,2,0)), axis = 2) # doklejenie w tyl - teraz pasuje bo odopowiednie przetransponowalismy doklejany do macirzy a1 plasterek a3 # przy dokleaniu ponuje mniej wiecej taka zasada zgocnosci wymiarow: # jezeli sklejam po wymiarze axis - n to dla pozostalych wymiarow roznych od n musi zachodzic zgodnosc rozmarow 8.1.9 operacje na kilku macierzach zwracajece jedna macierz a1 = np.array([[1,2],[3,4]]) a2 = np.array([10,20]) a1 + a2 # wektor a2 jest dodawany do kazdego wiersza macierzy a1 a1 * a2 # kolejne elementy kazdego wiersza a2 sa mnozone przez kolejne elementy wektora a1 8.1.10 sortowanie a1 = np.array([[7,5,3,6],[3,2,4,5]]) a1[np.argsort(a1[:, 0]),:] # po sortowanie po pierwszej kolumnnie a1[:,np.argsort(a1[0, :])] # po sortowanie po pierwszym wierszu 8.1.11 funkcje na macierzach a1 = np.array([[1,2],[3,4]]) a1.sum() # suma wszystkich elementow a1.sum(axis=1) # suma po wymiarze 1 np.apply_over_axes(np.sum, a1, [0]) # sum w po wierszach (w dol) np.apply_over_axes(np.sum, a1, [1]) # sum w po kolumnach (w prawo) np.apply_over_axes(func=lambda x, y: np.sum(x,y) , a=a1, axes=[1]) # to co linijke wyzej ale z uzyciem skladni funkcji anominowej. Do lambdy przekazalem argument x (kolejne wiersze) i y (axes - osie po ktorych ma byc sumowanie) np.apply_over_axes(func=lambda x, y: np.sum(x**2,y) , a=a1, axes=[1]) # sumuje po kolumnach, ale dodatkowo kazdy element podnosze do kwadratu a2 = np.array([[[1,2],[3,4]], [[5,6],[7,8]]]) # macierz 2x2X2 np.apply_over_axes(func=lambda x, y: np.sum(x**2,y) , a=a2, axes=[1]) # sumowanie po jednym wymiarze macierzy trojwymiarowej np.apply_over_axes(func=lambda x, y: np.sum(x**2,y) , a=a2, axes=[0,1]) # sumowanie po dwoch wymiarach macierzy trojwymiarowej 8.1.12 braki danych i wartosci nieskonczone import numpy as np a = np.array([[1, np.inf, 10], [3, np.nan, np.inf]]) # macierz z wartoscia nieskonczona i brakami danych a[np.isinf(a)] = -10 # zamiana wartosci nieskonczonych na -10 a[np.isnan(a)] = -1 # zamiana brakow danych na -1 a = np.array([[1,np.inf,10],[3,np.nan, np.inf]]) # macierz z wartoscia nieskonczona i brakami danych a[1, np.isinf(a)[1,]] = -10 # zamiana na 10 wartosci nieskonczonych w drugi wierszu a 8.1.13 rozne funkcje i triki a = np.array([[1,2],[3,4]]) a+1 # dodanie do wszystkich elementow wartosci 1 a*10 # pomnozenie wszystkich elementow przez wartosci 10 # UWAGA przypominam ze w przypadku np. list powyzsza skladania daje inne rezultaty: &#39;+ 1&#39; oznacza doklejenie elementu &#39;1&#39;,a &#39;* 10&#39; oznacza zwrocenie listy 10 razy: lista = [1,2,3,4] lista + [1] lista * 10 a = np.array([[1,7],[3,4]]) a.argmin(axis=0) # pozycja najmiejszego elementu dla kazdej kolumny a.argmin(axis=1) # pozycja najmiejszego elementu dla kazdego wiersza a.argmax(axis=0) # pozycja najwiekszego elementu dla kazdej kolumny 8.2 Scipy "],
["data-structures-other.html", "Chapter 9 DATA STRUCTURES - other", " Chapter 9 DATA STRUCTURES - other "],
["data-structures-objective-programing.html", "Chapter 10 DATA STRUCTURES - objective programing 10.1 tworzenie klasy i obiektow 10.2 metody i klasy prywatne 10.3 mechanizm dziedziczenia", " Chapter 10 DATA STRUCTURES - objective programing Programownie obiektowe technicznie jest proste. Sztuką jest dobrze wymyślić i zaprojektować obiekty tak żeby rzeczy rzeczywiście ułatwiały zarządzanie kodem programu. 10.1 tworzenie klasy i obiektow Utworzenie najprostszego obiektu #najpier tworze klase ktora jest szablonej do tworznia konkretnych obiektow tej klasy class pies: imie = &#39;Burek&#39; # tworze dwa obiekty (instancje klasy) klasy &#39;pies pies_1 = pies() pies_2 = pies() Atrubuty (zmienna zwiazane z klasami i obiektami) dzieli na - zwiazane z klasa. Beda je mialy wszystkie obiekty danej klasy - zwiazana z obiektami. Moga sie roznic pomiedzy obiektami Metody (czyli funkcje zwiazane z klasami i obiektami) rowniz dzielimy na - zwiazane z klasa. Operacje wykonywane przez te metody beda mialy wplyw na wszystkie instancje klasy - zwiazana z obiektami. Operacje wykonywane przez te metody beda mialy wplyw tylko na instancja na ktorych jest wykonywana funkcja Atrybuty metody i klasy #(1) znowu tworzymy klase class pies: # atrybut &#39;rodzaj&#39; bedzie dotyczyl wszystkich instancji tej klasy. Jest to atrybut dla calej klasy rodzaj = &#39;ssak&#39; # zeby stworzyc atrybuty ktorych wartosci moga sie roznic pomiedzy instancjami tworze funkcje inicjalizujaca (konstruktor), ktora bedzie automatycznie wywolywana przy tworzeniu obiektu def __init__(self, wiek, imie): # funkcja dotyczy instancji klasy i musi miec jako pierwszy argument &#39;self&#39;, ktory umozliwia jej operowanie na elementach tej instancji self.wiek_psa = wiek self.imie_psa = imie #(2) wywolanie funkcji __init__ nastepuje automatycznie przy tworzeniu obiektu: pies_1 = pies(wiek_psa = 10, imie_psa = &#39;burek&#39;) # teraz przy tworzeniu obiektu nadamy od razu cesze &#39;wiek_psa&#39; i &#39;imie_psa&#39; wartosc ktora nas interesje. Zauwazmy ze funkcja __init__ nie jest tutaj wywolywana przez nas z nazwy. Jest ona wywolywana automatycznie przy tworzeniu obiektu i domyslnie pobiera argumenty podane w nawiasach okraglych po nazwie funkcji tworzacej klase. pies_2 = pies(wiek_psa = 7, imie_psa = &#39;mirek&#39;) pies_3 = pies(wiek_psa = 11, imie_psa = &#39;puszek&#39;) Funkcje class pies: # atrybuty calej klasy rodzaj = &#39;ssak&#39; # funkcja dla instnacji bedaca funkcja inicjalizujaca def __init__(self, wiek, imie): # przypominam ze funkcje instakcji maja &#39;self&#39; jako pierwszy argument self.wiek_psa = wiek self.imie_psa = imie # funkcja dla instancji ( tym razem to nie jest funkcja inicjalizujaca) def wiek_ludzki(self): return(self.wiek_psa * 7) # funkcja dla klasu @classmethod # musze uzyc specjalnego dekoratora zeby poinformowac ze to funkcja dla calej klasy (o dekoratorze jest przyklad w pliku &quot;1_02_PROGRAMING_functions_and_environments&quot;) def zmiana_wielkosci_litery(cls, czy_na_male): # funkcje klasy maja cls jako pierwszy argument zeby funkcja mogla sie odnosic do klasy if czy_na_male: cls.radzaj = cls.rodzaj.lower # zamiana na male litery nazwy w atrbucie klasy else: cls.rodzaj = cls.rodzaj.upper # zamiana na male litery nazwy w atrbucie klasy pies_1 = pies(wiek = 5, imie = &#39;burek&#39;) pies_2 = pies(wiek = 15, imie = &#39;zbirek&#39;) # wywolanie atrybutu klasy pies_1.rodzaj pies_2.rodzaj # wywolanie atrybutow instancji pies_1.wiek_psa pies_1.imie_psa pies_2.wiek_psa pies_2.imie_psa # wywolanie funkcji instancji pies_1.wiek_ludzki() pies_2.wiek_ludzki() # wywolanie funkcji klasy pies_1.zmiana_wielkosci_litery(czy_na_male=False) pies_1.rodzaj() pies_2.rodzaj() #UWAGA!!!. Mimo ze wiekosc liter dla globalnego atrybutu zmienilismy tylko dla pies_1 to zmiana zaszla tak jak chcielismy dla calej klasy czyli dla wszystkich instancji. Dlatego dla pies_2 ssas tez jest pisany wielka litera O funkcjach statycznych # do uzupelnienia, ale chyba nie teraz 10.2 metody i klasy prywatne W programowaniu obiektowym elementy prywatne (atrybuty, funkcje) robi sie dla wewnetrznego uzytku obiektu. Sa to np. jakies pomocnicze funkcje ktorych uzytkownik nie powinien widziec, a ktorych rola jest np. wspieranie funkcji ktore sa z kolei wywolywane przez przez uzytownika (czyli funkcji publicznych. Dla scislosci wspomne ze funkcje w obiektach klas nazywa sie metodami. W Pythonie nazwy elementow prywatnych zaczynaja sie od podwojnego podkreslenia ’__’. class employee: def __init__(self, name, sal): self.__name=name # prywatny atrybut self.__salary=sal # prywatny atrybut def __pensja_netto(self): # funkcja prywatna print(self.__salary*0.8) emp = employee(name = &#39;lukasz&#39;, sal = 5000) emp.__salary # atrybutu salary nie sa sie wywolac bo jest prywatny i przez to niedostepny dla uzytkownika. Dostaniemy blad emp._employee__salary # ale mozna go wywalc posrednio taka nazwa: podkreslnik+nazwa_klasy_podkreslnik+nazwa_prywanego_atrybutu emp.__pensja_netto() # funkcji salary nie sa sie wywolac bo jest prywatna i przez to niedostepna dla uzytkownika. Dostaniemy blad emp._employee__pensja_netto()# ale mozna ja wywalc posrednio taka nazwa: podkreslnik+nazwa_klasy_podkreslnik+nazwa_prywanej_funkcji 10.3 mechanizm dziedziczenia 10.3.1 tworzenie podklas Klasy mozemy ukladac w hierachi. Jedna klasa moze miec wiele podklas. Jedna podklasa moze miec wiele nadklas. Podklasy dziedzicza cechy nadklasy, ale moga dodawac jakies swoje kolejne elementy. Np. Klasa ‘samochod’ oznacze posiadanie 4 kol i silnika. Podklasa ‘kabriolet’ ma wszystko to co ma klasa ‘samochod’ ale mozna jej dolozyc ceche ‘skladany_dach’. Dla podklasy mozemy stworzyc nastepna podklase, np. ‘kabriolet_elektryczny’, itd. # tworze klase &#39;robot&#39; class Robot: def __init__(self, name): self.name = name def say_hi(self): print(&quot;Hi, I am &quot; + self.name) # teraz tworze klase PhysicianRobot ktora jest podklasa klasy &#39;robot&#39; class PhysicianRobot(Robot): pass # slowo pass umozliwia utworzenie klasy bez podawania zadnych parametow. y = PhysicianRobot(&quot;James&quot;) #tworze obiekt klasy &#39;Robot&#39; y.say_hi() # mimo że w klasie &#39;PhysicianRobot&#39; nie zdefiniowalismy tej funkcji to zostala ona odziedziczona po klasie &#39;Robot&#39;.Dlatego dziala # teraz tworze klase OrganicRobot ktora jest kolejna (druga juz) podklasa klasy &#39;robot&#39; class OrganicRobot(Robot): # teraz dodamy sobie nowa funkcje ktorej nie ma klasa &#39;robot&#39; def say_goodbye(self): print(&#39;goodbye&#39;) x = OrganicRobot(&#39;Lucas&#39;) x.say_goodbye() 10.3.2 przeciazanie metod Przeciazanie metod. Polega na tym ze co prawda podklasa dziewczyny nazwe funkcji po nadklasie, ale niekoniecznie cialo tej funkcji. Czyli w podklasie funkcja moze robic cos innego nic w glownej klasie. # tworze klase &#39;robot&#39; class Robot: def __init__(self, name): self.name = name def say_hi(self): print(&quot;Hi, I am &quot; + self.name) # traz tworze klase PhysicianRobot ktora jest podklasa klasy &#39;robot&#39; class PhysicianRobot(Robot): def say_hi(self): # definiujemy tutaj jeszcze raz funkcje &#39;say_hi&#39; print(&quot;Everything will be okay! &quot;) print(self.name + &quot; takes care of you!&quot;) robot = Robot(&#39;blaszak&#39;) physical_robot = PhysicianRobot(&#39;robokop&#39;) # ponizej funkcje zwroca inne rezultaty robot.say_hi() physical_robot.say_hi() "],
["work-organisation.html", "Chapter 11 WORK ORGANISATION 11.1 importowanie pakietow/modulow 11.2 Wlasne moduly i pakiety 11.3 tworzenie wirtualnych srodowisk", " Chapter 11 WORK ORGANISATION 11.1 importowanie pakietow/modulow #(1) importpakietu &#39;pandas&#39; import pandas pandas.DataFrame() # odwolanie do funkcji w module #(2) przy imporicie mozna stosowac wlasne aliasy dla wygody import pandas as pd pd.DataFrame() # odwolanie do funkcji w module z uzyciem samodzielnie zdefiniowanego aliasu #(3) import bezposrednio konkretnego obiektu z pakietu &#39;random&#39; from random import randint randint(1,20) # teraz mozmy odwolywac sie bezposrednio do funkcji bez aliasu #(4) bezposredio importowanym obiektom tez mozna nawac wlasna nazwe from random import randint as rint rint(1,20) #(5) mozna bezposrednio zaimportowac wszystkie obiekty z danego pakietu (ale nie jest to zalecane - odpowiedz pod kodem) from random import * # Dlaczego nie uzywam się struktury: from pakiet import * # # You&#39;ll end up with a namespace where understanding what is what and from where it came from will be extremely hard, with difficulty increasing as the size of the overall project does. Appart from being completely unintuitive for Python, think of anybody else that might view your code or even worse, think about yourself re-reading it after 1 month and not remembering what&#39;s going on. You don&#39;t need that in your life. # # In addition to that, any functions you expose to the importer that might overlap with other functions in other modules are going to get shaddowed by the most recent one imported. As an example, think of two scripts that contain the same function foo() and watch what happens. # &gt;&gt;&gt; from scrpt1 import * # &gt;&gt;&gt; foo() # Script 1 # &gt;&gt;&gt; from scrpt2 import * # &gt;&gt;&gt; foo() # Script 2 11.2 Wlasne moduly i pakiety Modul i pakiet to nie do konca to samo. Modul to czysto technicznie rzecz biorac kazdy plik z rozszerzeniem ‘.py’ czyli kazdy plik ze skryptem pythonowym. Pakiet to sposob na uporzadkowanie i ustrukturyzowanie wiekszej ilosci modulow. 11.2.1 Wlasny modul Tworzymy prosty skrypt z jedna funkcja i zapisaumey go w katalogu pythona w ktorym pracujemy. Tresc skryptu ktory zapisze w ‘working directory’ pod nazwa ‘python_modul.py)’ (o tym jak sprawdzic ‘working directory jest w pliku ’1_11_PROGRAMING_tools_and_tricks’): def moja_funkcja(a,b): print(2*a+b) Plik jest zpisany i teraz z podzimy Pythona sobie importuje moduł import python_modul python_modul.moja_funkcja(20,30) # mam tearz dostep do mojej funkcji import pakiet_testowy_1.pakiet_testowy_cz_1 11.2.2 Wlasny pakiet - wersja uproszczona Pakiet to docelowa i zalecana uporzadkowana forma pracy z modulami. Najpierw w ‘working directory’ utworzymy katalog ktorego nazwa bedzie nazwa naszego pakietu Każdy pakiet w Pythonie jest folderem, który MUSI zawierać specjalny plik nazwany init.py. Ten plik może być pusty i służy informowaniu, że ten folder zawiera pakiet Pythona. Dzięki temu może być importowany tak samo jak moduły. Nastepnie dokladamy kolejne moduly ktore zawieraja juz wlasciwy kod i funkcje. W katalogu mozemy miec wiele plikow z kodem. Pliki moga np. wzajemnie importowac swoje obiekty. 11.2.3 Wlasny pakiet wg. standardu pip Na ta chwile to bardziej zaawansowany temat wiec sobie odpuscimy. https://packaging.python.org/tutorials/packaging-projects/ 11.3 tworzenie wirtualnych srodowisk Na komuterze mozemy tworzyc nowe wirtualne srodowiska pythonowe. Są one samowystarczalne, tzn. maja swoje bilbioteki i wlasny kompilator pythona. Jest to przydane np. w sytuacji kiedy mamy jakis proces ktory wymaga pythona z zainstalowanym okreslonym zestawem biliotek. Żeby by było konfliktu z pakietami na ktorych pracujemy przy innych zadaniach, powolujemy specjalnie dla tego procesu takie oddzielne samowystarczalne pythonowe wirtualne srodowisko Wykonujemy to poprzez: Uzywajac wiersza polecen, wchodzimy na dysku do lokalizacji gdzie chcemy zeby bylo nasze wirtualne srodowisko. Kiedy jestesmy na miejscu wykonujemy komende: python -m venv nazwa_srodowiska (mozemy nie wchodzic do lokalizacji tylko od razu podac sciezke gdzie na byc powolane wirtualne srodowisko: python -m venv sciezka/nazwa_srodowiska ) Na nowym srodowisku, mamy niezalenie odpalany oddzielny kompilator Pythona i mozemy niezaleznie instalowac biblioteki. "],
["data-import-and-export.html", "Chapter 12 DATA IMPORT AND EXPORT 12.1 pickles 12.2 csv / txt 12.3 excel 12.4 schowek", " Chapter 12 DATA IMPORT AND EXPORT 12.1 pickles Tzw. pickle sa uzywany do przechowywanie na dystku obiektow Pythonowych. ‘Picklowanie’ polega na serializacji obiektu: What pickle does is that it “serialises” the object first before writing it to file. Pickling is a way to convert a python object (list, dict, etc.) into a character stream. The idea is that this character stream contains all the information necessary to reconstruct the object in another python script. W picklach bedziemy tez np. przechowywac obiekty ktore przechowuja informacje o wytrenowanych modelach. import pickle example_dict = {1:&quot;6&quot;,2:&quot;2&quot;,3:&quot;f&quot;} # tworze przykladowy obiekt (slownik) pickle_out = open(&quot;dict.pickle&quot;,&quot;wb&quot;) # otwieramy/tworzymy plik w ktorym bedziemy chcieli przechowywac obiekt pickle.dump(example_dict, pickle_out) # ladujemy obiekt do pliku pickle_out.close() # zamukamy plik pickle_in = open(&quot;dict.pickle&quot;,&quot;rb&quot;) # otwieramy plik z zaladowanym obiektem example_dict = pickle.load(pickle_in) # ladujemy obiekt z pliku do pamieci 12.2 csv / txt 12.2.1 Import W pakiecie ‘Pandas’ jest funkcja ktora umozlwia ladowanie danych z plikow csv i txt bezposrednio do DataFrame. import pandas as pd pd.read_csv(&#39;data.csv&#39;) pd.read_csv(&#39;data.csv&#39;, sep = &#39;\\t&#39;, delimiter = &#39;,&#39;, thousands = &#39; &#39;) # ustalamy separator miedzy kolumnami jako tabulacja, separator ulamka w liczbie jako przecinek i separator tysieczny jako spacja pd.read_csv(&#39;data.csv&#39;, encoding=&#39;udf-8&#39;) # ustawienie kodowania # pelna lista parametrow na stronie: https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html 12.2.2 Eksport W pakiecie ‘Pandas’ jest funkcja ktora umozlwia zapis danych z DataFrame do plikow csv i txt. df = pd.DataFrame({&#39;name&#39;: [&#39;Raphael&#39;, &#39;Donatello&#39;], ... &#39;mask&#39;: [&#39;red&#39;, &#39;purple&#39;], ... &#39;weapon&#39;: [&#39;sai&#39;, &#39;bo staff&#39;]}) df.to_csv(path_or_buf = &#39;plik.csv&#39;, index=False, sep = &#39;,&#39;) # W pozyzszej funkcji jest dostepna wiekszosc parametrow ktore mamy z funkcji &#39;read_csv&#39; 12.3 excel 12.3.1 Import W pakiecie ‘Pandas’ mozemy tez bezposrednio do DataFrame importowac plik excelowski import pandas as pd pd.read_excel(io = &#39;plik.xlsx&#39;, sheet_name = &#39;Arkusz1&#39;) 12.3.2 Eksport Export DataFrame do excela import pandas as pd df1 = pd.DataFrame([[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]], index=[&#39;row 1&#39;, &#39;row 2&#39;], columns=[&#39;col 1&#39;, &#39;col 2&#39;]) df1.to_excel(&quot;output.xlsx&quot;, sheet_name = &#39;Arkusz_10&#39;) # doctest: +SKIP 12.4 schowek Mozemy np. zrobic Ctrl+C komorek w excelu i ‘zlapac’ tabele bezposrednio do zmiennej typu DataFrame import pandas as pd z = pd.read_clipboard(sep=&#39;,&#39;) # niestety separator jest jedynym parametrem ktory mozna ustawic z "],
["tools-and-tricks.html", "Chapter 13 TOOLS AND TRICKS 13.1 praca z katalogami i plikami 13.2 Podstawowe polecenia w konsoli 13.3 python 13.4 pommiar czasu wykonania kodu", " Chapter 13 TOOLS AND TRICKS 13.1 praca z katalogami i plikami Wyswietlanie zawartosci katalogu import os # wszystkie pliki i katalogi w podanej sciezce os.listdir(path = &#39;C:/Users/memy/OneDrive/Pulpit/1_Programs_and_programing/R/1.MANUAL_R/&#39;) # wszystkie pliki i katalogi w podanej sciezce z podana pelna sciezka import glob z=glob.glob(&#39;C:/Users/memy/OneDrive/Pulpit/1_Programs_and_programing/R/1.MANUAL_R/*.*&#39;) z # wszystkie pliki i katalogi w podanej sciezce (inna skladnia) for entry in os.scandir(&#39;C:/Users/memy/OneDrive/Pulpit/1_Programs_and_programing/R/1.MANUAL_R/&#39;): print(entry.name) # same katalogi for entry in os.scandir(path): if entry.is_dir(): print(entry.name) # same pliki for entry in os.scandir(path): if entry.is_file(): print(entry.name) # same pliki o rozszerzeniu .sas import glob glob.glob(&#39;C:/Users/memy/OneDrive/Pulpit/1_Programs_and_programing/R/1.MANUAL_R//*.sas&#39;) Tworzenie katalogu # tworzenie katalogu os.mkdir(path) Usuwanie pliku lub katalogu # kasowanie katalogu os.rmdir(path) Przenoszenie pliku lub katalogu # przenoszenie pliku/katalogu (https://www.techbeamers.com/python-copy-file/) import shutil shutil.copy(file, descination) 13.2 Podstawowe polecenia w konsoli Przydatne funkcje wywolywane w konsoli (nie jest to kod Pythonowy!!!). Konsola to wiersz polecen w Windowsie. Uwaga, żeby nie było żadnych nieprzewidzianych konfliktow, to przed rozpoczeciem pracy z konsoli najlepiej wywolac srowowisko pythonowe w ktorym chcemy pracowac. # jeszcze RAZ PRZYPOMINAM: ponizszy kod to nie jest kod pythona. Wykonujemy go w wierszu poleceń a nie w narzędziu do programowania w pythonie. # Lista zainstalowanych pakietow w srodowisku w ktorym aktualnie pracujemy pip list # ograniczam liste do pakietow ktore maja w nazwie string &quot;pandas&#39; pip list | findstr pandas # lista pakietow ktore nie sa najnowszymi wersjami (warto sprawdzic czy nie warto dla nich zrobic aktualizacji) pip list --outdated # lista pakietow ktore sa najmowyszymi wersjami pip list --uptodated # instalacja pakietu pillow w najnowszej dostepnej wersji pip install pillow # upgrade zainstalowanego pakietu pillow do najnowszej wersji pip install --upgrade pillow # instalacja pakietu &#39;pillow&#39;, ale o konkretnym numerze wersji pip install pillow==5.2.0 pip install pillow&gt;=5.1.0,&lt;5.3.0 # mozemy tez uzywac znakow nieroznowci przy podawaniu wersji # wymuszenie reinstalacji pakietu &#39;pillow&#39; pip install --upgrade --force-reinstall pillow # wymuszenie reinstalacji pakietu &#39;pillow&#39; ale bez wymuszania reinstalacja pakietow ktore sa zalezne pip install --upgrade --no-deps --force-reinstall &lt;packagename&gt; # wyszukanie okreslownych pakietow w srodowisku w ktorym pracujemy pip search pands # uruchomienie skryptu pythonowego w konsoli python main_program.py 13.3 python Ponizsze kody sa juz Pythonnowe import os # working directory - bieżący roboczy katalog print(os.getcwd()) # pelna sciezka do katalogu os.path.abspath(&quot;&quot;) # teraz dostane pelna sciezke katalogu w ktorym pracuje (working directory) os.path.abspath(&quot;../&quot;) # co co wyzej ale jeden katalog w gore os.path.abspath(&quot;../../&quot;) # co co wyzej ale dwa katalogi w gore os.path.abspath(&quot;output.xlsx&quot;) # pelna sciezka do poliku &#39;output&#39; w katalogu roboczym # environmental variables (lisa zmiennych srodowiskowych w Windowsie) os.get_exec_path() # check if Python environment exists import os if os.getenv(&#39;VIRTUAL_ENV&#39;): # provide environment name you are looking for print(&#39;Using Virtualenv&#39;) else: print(&#39;Not using Virtualenv&#39;) # run commans in the shell os.system(r&quot;\\\\spplfapcen02\\userdata\\UN99LT\\Desktop\\smietnik\\klienci.xlsx&quot;) # remember about letter &quot;r&quot; at the beginning 13.4 pommiar czasu wykonania kodu import time start = time.time() # rozpoczecie pomiaru czasu # przetestujemy czas wykonania petli a = range(100000) b = [] for i in a: b.append(i*2) end = time.time() # zakonczenie pomiaru czasu print(end - start) # czasy wykonania jako roznica uzyskanych czasow "],
["big-packages.html", "Chapter 14 big packages 14.1 matplotlib 14.2 seaborn 14.3 plotly 14.4 bokeh 14.5 plotnine", " Chapter 14 big packages 14.1 matplotlib 14.2 seaborn 14.3 plotly 14.4 bokeh 14.5 plotnine Ten pakiet jest klon slynnego pakietu ggplot2 from plotnine import * import seaborn as sns # dla importu danych iris = sns.load_dataset(&#39;iris&#39;) # wykres gestosci (ggplot(iris) + geom_density(aes(x=&#39;sepal_length&#39;)) ) # wykres gestosci grupowany (ggplot(iris) + geom_density(aes(x=&#39;sepal_length&#39;, fill = &#39;species&#39;), alpha = 0.5, adjust = 0.2) ) # wykres gestoci grupowany po facet (ggplot(iris) + geom_density(aes(x=&#39;sepal_length&#39;)) + facet_grid(&#39;.~species&#39;, scales=&#39;free&#39;) ) "],
["other-packages.html", "Chapter 15 other packages", " Chapter 15 other packages "],
["graphs.html", "Chapter 16 graphs", " Chapter 16 graphs "],
["maps.html", "Chapter 17 maps", " Chapter 17 maps "],
["other-issues.html", "Chapter 18 other issues", " Chapter 18 other issues "],
["cooperation-with-other-tools.html", "Chapter 19 Cooperation with other tools 19.1 Relational databases 19.2 Norelational databases 19.3 R", " Chapter 19 Cooperation with other tools 19.1 Relational databases 19.1.1 SQL Server Łączenie się do SQL server przez sterowniki Windowsowe ODBC i pakiet pyodbc import pyodbc #(1) Jezeli sql server jest na innym komputerze/serwerze to tworze poleczenie do serwera zgodnie ze stringiem o skladni: conn = pyodbc.connect(&quot;DRIVER={sterownik};SERVER=nazwa_servera;DATABASE=nazwa_bazy;UID=nazwa_uzytkownika;PWD=haslo&quot;) #(2) Jezeli sql server jest localhostem uzywamy skladni: conn = pyodbc.connect(&#39;DRIVER={sterownik};Server=nazwa_servera_server;Database=nazwa_bazy;Trusted_Connection=yes;&#39;) # na moim lokalnym komputerze laczenie z localhostem wylada tak: conn = pyodbc.connect(&#39;DRIVER={ODBC Driver 17 for SQL Server};Server=DESKTOP-BACLRCB;Database=Test;Trusted_Connection=yes;&#39;) # Ja mam wpisane ze sterownik to &quot;ODBC Driver 17 for SQL Server&quot; ale mozesz miec inna wersje sterownika ODBC. Sprawdz to sobie w podgladzie sterownikow ODBC w Windowsie. Nazwe servera sprawdzisz w &quot;Management Studio&quot; # UWAGA!!!: Ja mam zainstalowany SQL Server Developer. Jezli masz SQL Server Express to przy nazwie serwera w powyzszych stringach polaczenie powinna byc skladnia: &#39;nazwa_serwera\\\\SQLEXPRESS&#39; a nie samo &#39;nazwa_serwera&#39; Łączenie się do SQL server przez pakiet sqlAlchemy from sqlalchemy import create_engine import urllib import pyodbc import pandas as pd # wklejam string polaczenia zgodnie ze sposobem opisanym w podrozdzialen &#39;Łączenie się do SQL server przez sterowniki Windowsowe ODBC i pakiet pyodbc&#39;: quoted = urllib.parse.quote_plus(&quot;DRIVER={ODBC Driver 17 for SQL Server};Server=DESKTOP-BACLRCB;Database=Test;Trusted_Connection=yes;&quot;) # tworze patametry dla polaczenie pod pokiet sqlAlchemy bazujac na wczeniej zdefiniowanym stringu polaczenia engine = create_engine(&#39;mssql+pyodbc:///?odbc_connect={}&#39;.format(quoted)) # lacze sie do bazy conn = engine.connect() Ladowanie/insertowanie danych Uwaga: zeby ladowac dane bezposrednio z DataFrames musimy na ta chwile uzyc podloczenia sie przez pakiet ‘sqlAlchemy’ a nie ‘pyodbc’. from sqlalchemy import create_engine import urllib import pyodbc import pandas as pd # przygotowuje DataFrame do zaladowania df = pd.DataFrame({&#39;A&#39;:[1,2,3,4,5], &#39;B&#39;:[7,8,9,10,11]}) # lacze sie do bazy zgodnie z logika pakietu &#39;sqlAlchemy&#39; quoted = urllib.parse.quote_plus(&quot;DRIVER={ODBC Driver 17 for SQL Server};Server=DESKTOP-BACLRCB;Database=Test;Trusted_Connection=yes;&quot;) engine = create_engine(&#39;mssql+pyodbc:///?odbc_connect={}&#39;.format(quoted)) conn = engine.connect() # laduje tabele do bazy df.to_sql(name=&#39;nowa_tabela&#39;, con = conn, if_exists=&#39;append&#39;) # parametr &#39;if_exists&#39; mowi co zrobic gdyby tabela &#39;nowa_tabela&#39; juz istniala w bazie. Wartosc &#39;append&#39; oznacze ze do istaniejacej tabeli zostana dodane wiersze. Inne mozliwe wartosci to &#39;fila&#39; i &#39;replace&#39; Pobieranie danych Tutaj mozemy laczyc sie zarowno przez pakiet ‘sqlAlchemy’ jak i ‘pyodbc’ import pandas as pd import pyodbc # lacze sie do bazy sterownikiem ODBC przez pakiet &#39;pyodbc&#39; (mozemy tez oczywiscie uzyc rozwiazania a pakietu sqlAlchemy) conn = pyodbc.connect(&#39;DRIVER={ODBC Driver 17 for SQL Server};Server=DESKTOP-BACLRCB;Database=Test;Trusted_Connection=yes;&#39;) # przygotowuje string z zapytaniem SQL sql = &#39;SELECT top 10 * FROM recipes&#39; # pobieram dane df = pd.read_sql(sql=sql, con=conn) Wykonywanie dowolnego stringu SQL na bazie import pyodbc conn = pyodbc.connect(&#39;DRIVER={ODBC Driver 17 for SQL Server};Server=DESKTOP-BACLRCB;Database=Test;Trusted_Connection=yes;&#39;) cursor = conn.cursor() cursor.execute(&quot;drop table recipes&quot;) # przyklad sql-a uzuwajacego tabele cursor.commit() cursor.close() 19.1.2 Postgres Łączenie się do bazy pakietem ‘sqlalchemy’. Nie wymaga zainstalowanych sterownikow ODBC import sqlalchemy # trzeba miec roznie zainstalowany pakiet &#39;psycopg2&#39; !!!. Inaczej funkcje z pakietu &#39;sqlalchemy&#39; nie beda dzialac import pandas as pd # utorzenie polaczenia: skladnia stringu polaczenia to &#39;postgresql+psycopg2://uzytkownik:haslo@server:port/baza&#39; engine = sqlalchemy.create_engine(&#39;postgresql+psycopg2://postgres:postgres@localhost:5432/postgres&#39;) # skladnia polazenia conn = engine.connect() conn.close() # zakonczenie polaczenia z baza Łączenie się do bazy pakietem ‘pyodbc’. Wymaga zainstalowanych sterownikow ODBC import pyodbc connection = pyodbc.connect(&quot;DRIVER={PostgreSQL Unicode};SERVER=localhost;DATABASE=postgres;UID=postgres;PWD=password&quot;) conn.close() # zakonczenie polaczenia z baza Ładowanie danych do bazy Uwaga: zeby ladowac dane bezposrednio z DataFrames musimy na ta chwile uzyc podloczenia sie przez pakiet ‘sqlAlchemy’ a nie ‘pyodbc’. import sqlalchemy # trzeba miec roznie zainstalowany pakiet &#39;psycopg2&#39; !!!. Inaczej funkcje z pakietu &#39;sqlalchemy&#39; nie beda dzialac import pandas as pd # utorzenie polaczenia: skladnia stringu polaczenia to &#39;postgresql+psycopg2://uzytkownik:haslo@server:port/baza&#39; engine = sqlalchemy.create_engine(&#39;postgresql+psycopg2://postgres:postgres@localhost:5432/postgres&#39;) # skladnia polazenia conn = engine.connect() # Tworze DataFrame ktora bedzie eksportowana do Postgresa lista_hello = [&#39;hello4&#39;, &#39;hello5&#39;] lista_world = [&#39;world4&#39;, &#39;world5&#39;] df = pd.DataFrame(data={&#39;hello&#39;: lista_hello, &#39;world&#39;: lista_world}) # wyslanie DataFrame do Postgresa df.to_sql(name=&#39;helloworld2&#39; , con=engine , if_exists=&#39;append&#39; # &#39;if exists = append&#39; oznacze ze jezeli tabela istnieje to nokordy beda dodane. , index=False) conn.close() # zakonczenie polaczenia z baza Pobieranie danych Tutaj mozemy laczyc sie zarowno przez pakiet ‘sqlAlchemy’ jak i ‘pyodbc’. import sqlalchemy # trzeba miec roznie zainstalowany pakiet &#39;psycopg2&#39; !!!. Inaczej funkcje z pakietu &#39;sqlalchemy&#39; nie beda dzialac import pandas as pd # utorzenie polaczenia: skladnia stringu polaczenia to &#39;postgresql+psycopg2://uzytkownik:haslo@server:port/baza&#39; engine = sqlalchemy.create_engine(&#39;postgresql+psycopg2://postgres:postgres@localhost:5432/postgres&#39;) # skladnia polazenia conn = engine.connect() # pobranie danych z bazy Postgres (SPOSOB 1) from sqlalchemy.sql import text s = text( &quot;SELECT * &quot; &quot;FROM helloworld &quot; &quot;WHERE world = :word &quot;) result = conn.execute(s, word=&#39;world5&#39;).fetchall() # string &#39;world5&#39; bedzie w kwerendzie postawiony pod &#39;:word&#39; pd.DataFrame(result) # pobranie danych z bazy Postgres (SPOSOB 2) df12 = pd.read_sql_query(sql=&#39;select * from helloworld where world={}&#39;.format(&quot;&#39;world5&#39;&quot;), con=conn) conn.close() # zakonczenie polaczenia z baza Wykonywanie dowolnego polecenia na bazie # przylad pobrania listy tabel w schemacie &#39;public&#39; q = conn.execute(&quot;SELECT tablename FROM pg_catalog.pg_tables where schemaname = &#39;public&#39;&quot;).fetchall() conn.close() # zakonczenie polaczenia z baza 19.1.3 Oracle 19.1.4 MySql 19.2 Norelational databases 19.2.1 Neo4j 19.2.2 Redis 19.2.3 MongoDB 19.3 R "],
["www.html", "Chapter 20 www 20.1 Flask 20.2 Django", " Chapter 20 www 20.1 Flask 20.2 Django "],
["good-habits.html", "Chapter 21 good habits", " Chapter 21 good habits "],
["ide.html", "Chapter 22 IDE 22.1 Jupiter 22.2 PyCharm", " Chapter 22 IDE 22.1 Jupiter 22.2 PyCharm "],
["intro-1.html", "Chapter 23 INTRO", " Chapter 23 INTRO "]
]
